{"version":3,"file":"sfd.js","mappings":"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xB,CAAP;AACD,GAZa;AAcdtC,EAAAA,OAAO,EAAE,iBAASvI,GAAT,EAAc;AACrB,qBAA2BA,GAAG,CAAC+K,KAAJ,CAAUF,SAAV,CAA3B;AAAA;AAAA,QAAOlN,IAAP;AAAA,QAAaS,IAAb;AAAA,QAAmBwT,IAAnB;;AAEA,WAAQjU,IAAI,IAAIqC,GAAR,GAAc,IAAd,GAAqB;AAC3B/C,MAAAA,QAAQ,EAAEU,IADiB;AAE3BC,MAAAA,YAAY,EAAEQ,IAFa;AAG3B4G,MAAAA,OAAO,EAAE4M;AAHkB,KAA7B;AAKD;AAtBa,CAAhB;AAyBAzS,MAAM,CAACC,OAAP,GAAiB7C,OAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,KAAK;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA,gFAAgF;AAChF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA,IAAI;AACJ;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA,kDAAkD,4BAA4B;AAC9E;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,8DAA8D;AACnF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,4BAA4B;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,2DAA2D;AAC3D,0CAA0C;AAC1C;AACA;AACA,sCAAsC;AACtC,2CAA2C;AAC3C;AACA;AACA;;AAEA,kDAAkD,sCAAsC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,kEAAkE;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,uDAAuD;AACvD,0CAA0C;AAC1C,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,4EAA4E;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,6EAA6E,eAAe;AAC5F,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,GAAG;AACH;AACA,qCAAqC,wCAAwC;AAC7E;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL,2BAA2B,sBAAsB;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,wDAAwD;AACnF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEAAgE;AAC3F;AACA;AACA;AACA,4BAA4B,+CAA+C;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uCAAuC;AACpE,gCAAgC,sDAAsD;AACtF;AACA;AACA,6CAA6C,gDAAgD;AAC7F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB;AAC/D,qDAAqD,gBAAgB,8BAA8B,gBAAgB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;;AAEA;AACA,gEAAgE,eAAe;AAC/E;;AAEA;AACA;AACA;;AAEA;AACA,uDAAuD,iBAAiB;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,8DAA8D,oCAAoC;AAClG;;AAEA;AACA;AACA;;AAEA,8DAA8D;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB;AAChE,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,iCAAiC,KAAK;AACtC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,yBAAyB;AACnE,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS,WAAW;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,WAAW;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wBAAwB;AAC7D,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sCAAsC,0BAA0B,IAAI;AACxG,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB;AAChE,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,KAAK;AAC7C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,mDAAmD;AAC5E;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,0CAA0C;AAC9F;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oBAAoB;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,KAAK;AACtC;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,sBAAsB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C,4DAA4D,wBAAwB;AACpF;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,6BAA6B;AACrE;AACA;AACA,yCAAyC,8BAA8B;AACvE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,6BAA6B;AACrE;AACA;AACA,uCAAuC,8BAA8B;AACrE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,4BAA4B;AAC1E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA,wCAAwC,gCAAgC;AACxE,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,gFAAgF,cAAc;AAC9F,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,yCAAyC,4BAA4B;AACrE,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,yCAAyC,8BAA8B;AACvE,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA,2CAA2C,gCAAgC;AAC3E,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,8DAA8D;AAC7F;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,8CAA8C;AAC7E;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,8DAA8D;;AAE9D;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uBAAuB;AAC7D,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2DAA2D;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oBAAoB;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,KAAK;AAC7C;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2DAA2D,4BAA4B;AACvF;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iEAAe,SAAS,EAAC;AACif;;;;;;;;;;;;ACvyL1gB;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA","sources":["webpack://sfd/webpack/universalModuleDefinition","webpack://sfd/./src/core/component/Block.js","webpack://sfd/./src/core/component/Content.js","webpack://sfd/./src/core/component/Editor.js","webpack://sfd/./src/core/component/Leaf.js","webpack://sfd/./src/core/component/TextNode.js","webpack://sfd/./src/core/event/eventHandler.js","webpack://sfd/./src/core/event/handlers/onBeforeInput.js","webpack://sfd/./src/core/event/handlers/onInput.js","webpack://sfd/./src/core/event/handlers/onKeyDown.js","webpack://sfd/./src/core/event/handlers/onSelect.js","webpack://sfd/./src/core/event/keyMap.js","webpack://sfd/./src/core/event/keys.js","webpack://sfd/./src/core/selection/castSelection.js","webpack://sfd/./src/core/selection/findOffsetKey.js","webpack://sfd/./src/core/selection/getCastSelection.js","webpack://sfd/./src/core/selection/getOffsetKey.js","webpack://sfd/./src/model/constants/styleMap.js","webpack://sfd/./src/model/decorator/Decorator.js","webpack://sfd/./src/model/immutable/CharMeta.js","webpack://sfd/./src/model/immutable/ContentBlock.js","webpack://sfd/./src/model/immutable/ContentState.js","webpack://sfd/./src/model/immutable/EditorState.js","webpack://sfd/./src/model/immutable/SelectionState.js","webpack://sfd/./src/model/immutable/Tree.js","webpack://sfd/./src/model/immutable/findRange.js","webpack://sfd/./src/model/modifiers/DOMModifier.js","webpack://sfd/./src/model/modifiers/modifier.js","webpack://sfd/./src/model/transaction/insertToList.js","webpack://sfd/./src/sfd.js","webpack://sfd/./src/utils/asserts.js","webpack://sfd/./src/utils/keyUtil.js","webpack://sfd/./node_modules/immutable/dist/immutable.es.js","webpack://sfd/external umd {\"root\":\"React\",\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\"}","webpack://sfd/webpack/bootstrap","webpack://sfd/webpack/runtime/define property getters","webpack://sfd/webpack/runtime/hasOwnProperty shorthand","webpack://sfd/webpack/runtime/make namespace object","webpack://sfd/webpack/before-startup","webpack://sfd/webpack/startup","webpack://sfd/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sfd\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"sfd\"] = factory(root[\"React\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE_react__) {\nreturn ","// @flow\n'use strict';\n\nconst keyUtil = require('keyUtil')\nconst Leaf = require('Leaf')\nconst Decorator = require('Decorator')\nconst ContentBlock = require('ContentBlock')\nconst EditorState = require('EditorState')\nconst React = require('react')\nconst {List} = require('immutable')\n\ntype Props = {\n  offsetKey: ?string,\n  blockKey: string,\n  block: ContentBlock,\n  tree: List<any>,\n  decorator: Decorator\n}\n\nclass Block extends React.Component<Props> {\n  constructor(props:Props) {\n    super(props)\n  }\n\n  render(): React.Node {\n    const {blockKey, offsetKey} = this.props\n    \n    return (\n      <div className='editor-block'\n        key={blockKey}\n        data-offset-key={offsetKey}>\n        {this.renderChildren()}\n      </div>\n    )\n  }\n\n  renderChildren(): React.Node[] {\n    const {blockKey, block, tree, decorator} = this.props\n    const text = block.getText()\n\n    return tree.map((blockRange, key1) => {\n      const decoratorKey = blockRange.get('decoratorKey'),\n            leaves = blockRange.get('leaves'),\n            start = blockRange.get('start'),\n            end = blockRange.get('end')\n\n      if(leaves.size == 0) {\n        return null\n      }\n\n      const Leaves = leaves.map((leafRange, key2) => {\n        const offsetKey = keyUtil.encodin(blockKey, key1, key2),\n              start = leafRange.get('start'),\n              end = leafRange.get('end')\n\n        const leafProps = {\n          offsetKey,\n          text: text.slice(start, end),\n          inlineStyle: block.getStyleAt(start)\n        }\n        \n        return <Leaf key={offsetKey} {...leafProps}/>\n      }).toArray()\n      \n      if(decoratorKey == null || !decorator) {\n        return Leaves\n      }\n\n      const decoratorOffsetKey = keyUtil.encodin(blockKey, key1, 0)\n      const DecoratorComponent = decorator.getComponentForKey(decoratorKey),\n            decoratorProps = decorator.getPropsForKey(decoratorKey),\n            decoratorProps1 = {\n              offsetKey: decoratorOffsetKey,\n              blockKey,\n              start: leaves.first().get('start'),\n              end: leaves.first().get('end'),\n              text: text.slice(start, end)\n              // entityKey: content.getEntityAt()\n            }\n\n      return (\n        <DecoratorComponent key = {decoratorOffsetKey} {...decoratorProps1} {...decoratorProps}>\n          {Leaves}\n        </DecoratorComponent>\n      )\n    }).toArray()\n  }\n}\n\nmodule.exports = Block\n","// @flow\n'use strict';\n\nconst keyUtil = require('keyUtil')\nconst Block = require('Block')\nconst Tree = require('Tree')\nconst ContentState = require('ContentState')\nconst EditorState = require('EditorState')\nconst React = require('react')\n\ntype Props = {\n  editor: Editor,\n  editorState: EditorState\n}\n\nclass Content extends React.Component<Props> {\n  constructor(props: Props) {\n    super(props)\n  }\n  \n  render(): React.Node {\n    const {editor, editorState} = this.props\n    const content = editorState.getContent()\n    \n    return (\n      <div className='editor-content'>\n          {this.renderChildren(editorState, content)}\n      </div>\n    )\n  }\n\n  renderChildren(\n    editorState: EditorState,\n    content: ContentState\n  ): React.Node {\n    const trees = editorState.getTreeMap(),\n          decorator = editorState.getDecorator()\n    let Blocks = [];\n\n    //blockArray = content.getBlockArray\n    trees.map((tree, key) => {\n      const offsetKey = keyUtil.encodin(key, 0, 0),\n            block = content.getBlockForKey(key),\n            props = {\n              offsetKey,\n              blockKey: key,\n              block,\n              tree,\n              decorator\n            }\n\n      Blocks.push(<Block key={key} {...props}/>)\n    })\n    \n    return (\n      <div data-content='true'>\n        {Blocks}\n      </div>\n    )\n  }\n}\n\nmodule.exports = Content\n","// @flow\n'use strict';\n\nconst keyMap = require('keyMap')\nconst eventHandler = require('eventHandler')\nconst Content = require('Content')\nconst EditorState = require('EditorState')\nconst React = require('react')\n\ntype Props = {\n  editorState: EditorState,\n  onChange: (editorState: EditorState)=>void,\n  readOnly: boolean,\n  keyMap: Function\n}\n\ntype DefaultProps = {\n  readOnly: boolean,\n  keyMap: Function\n}\n\nclass UpdateEditor extends React.Component<{\n  editor: Editor,\n  editorState: EditorState\n}> {\n  componentDidMount() {\n    this.sync()\n  }\n\n  componentDidUpdate() {\n    this.sync()\n  }\n\n  render(): React.Node {\n    return null\n  }\n\n  sync() {\n    const { editor, editorState } = this.props\n    editor._latestEditorState = editorState\n    editor._blockSelectEvent = true\n  }\n}\n\nclass Editor extends React.Component<Props> {\n  static defaultProps: DefaultPropss = {\n    readOnly: false,\n    keyMap: keyMap\n  }\n\n  editor: ?HTMLElement\n  editorContainer: ?HTMLElement\n  refContainer: (node: ?HTMLElement) => void = (node) => {\n    this.editorContainer = node\n    this.editor = node != null ? (node: any).firstChild : null\n  }\n  _blockSelectEvent: boolean\n  _latestEditorState: EditorState\n  _pendingEditorState: ?EditorState\n  onKeyDown: Function\n  onBeforeInput: Function\n  onInput: Function\n  onSelect: Function\n  \n  constructor(props: Props) {\n    super(props)\n\n    this._blockSelectEvent = false\n    this._latestEditorState = props.editorState\n    this.onKeyDown = this.buildHandler('onKeyDown')\n    this.onBeforeInput = this.buildHandler('onBeforeInput')\n    this.onInput = this.buildHandler('onInput')\n    this.onSelect = this.buildHandler('onSelect')\n    // this.onKeyUp = this.buildHandler('onKeyUp')\n    // this.onMouseUp = this.buildHandler('onMouseUp')\n  }\n\n  componentDidMount(): void {\n    this._blockSelectEvent = false\n  }\n  \n  componentDidUpdate(): void {\n    this._latestEditorState = this.props.editorState\n    this._blockSelectEvent = false\n  }\n\n  render(): React.Node {\n    const { editorState, readOnly } = this.props\n\n    const style = {\n      outline: 'none',\n      // fix parent-draggable Safari bug. #1326\n      userSelect: 'text',\n      WebkitUserSelect: 'text',\n      whiteSpace: 'pre-wrap',\n      wordWrap: 'break-word',\n    }\n\n    return (\n      <div className='editor-paren'>\n        {this.renderPlaceholder()}\n        <div className='editor-container'\n             ref={this.refContainer}>\n          <div className='editor'\n               style={style}\n               onKeyDown={this.onKeyDown}\n               onBeforeInput={this.onBeforeInput}\n               onInput={this.onInput}\n               onSelect={this.onSelect}\n               contentEditable={!readOnly}\n               suppressContentEditableWarning>\n            <UpdateEditor editor={this} editorState={editorState}/>\n            <Content editor={this.editor} editorState={editorState}/>\n          </div>\n        </div>\n      </div>\n    )\n  }\n\n  renderPlaceholder(): React.Node {\n    const {editorState, placeHolder} = this.props\n    const withHolder = placeHolder && !!placeHolder.toString().trim(),\n          withContent = editorState.getContent().getBlockMap()\n          .some(block=>!!block.getText().length)\n\n    return withHolder && !withContent ? (\n      <div className='editor-placeholder'>\n        {placeHolder}\n      </div>\n    ) : null\n  }\n\n  sync(editorState: EditorState): void {\n    this._latestEditorState = editorState\n    this.props.onChange(editorState)\n  }\n\n  buildHandler(event: string): Function {\n    return e => {\n      const handler = eventHandler[event]\n      return handler(this, e)\n    }\n  }\n}\n\nmodule.exports = Editor\n","// @flow\n'use strict';\n\nimport type {InlineStyle} from 'InlineStyle'\nconst TextNode = require('TextNode')\nconst styleMap = require('styleMap')\nconst React = require('react')\n\ntype Props = {\n  offsetKey: string,\n  text: string,\n  inlineStyle: InlineStyle\n}\n\nclass Leaf extends React.Component<Props> {\n  constructor(props:Props) {\n    super(props)\n  }\n  \n  render(): React.Node {\n    const {offsetKey, text, inlineStyle} = this.props\n    const style = inlineStyle.reduce((styles, style, _)=>{\n      const slice = styleMap[style]\n      return Object.assign(styles, slice)\n    }, {})\n    \n    return (\n      <span\n        key={offsetKey}\n        data-offset-key={offsetKey}\n        style={style}>\n        <TextNode>{text}</TextNode>\n      </span>\n    )\n  }\n}\n\nmodule.exports = Leaf\n","// @flow\n'use strict';\n\nconst React = require('react')\n\ntype Props = {children: string}\n\nclass TextNode extends React.Component<Props> {\n  constructor(props: Props) {\n    super(props)\n  }\n\n  render(): React.Node {\n    const newLine = this.props.children == ''\n\n    return newLine ? (\n      <br data-text='true'/>\n    ) : (\n      <span data-text='true'>\n        {this.props.children}\n      </span>\n    )\n\n  }\n}\n\nmodule.exports = TextNode\n","'use strict';\n\n// const onFocus = require('onFocus')\n// const onBlur = require('onBlur')\nconst onKeyDown = require('onKeyDown')\nconst onBeforeInput = require('onBeforeInput')\nconst onInput = require('onInput')\nconst onSelect = require('onSelect')\n\nconst eventHandler = {\n  // onFocus,\n  // onBlur,\n  onKeyDown,\n  onBeforeInput,\n  onInput,\n  onSelect,\n  onKeyUp: onSelect,\n  onMouseUp: onSelect\n};\n\nmodule.exports = eventHandler\n","// @flow\n'use strict';\n\nimport type {InlineStyle} from 'InlineStyle'\nconst EditorState = require('EditorState')\nconst Editor = require('Editor')\nconst modifier = require('modifier')\n\n\n// function onBeforeInput(\n//   _this: Editor,\n//   e: SyntheticInputEvent<HTMLElement>\n// ):void {}\n\nfunction onBeforeInput(\n  _this: Editor,\n  e: SyntheticInputEvent<HTMLElement>\n): void {\n  console.log('BEFOREINPUT')  \n  \n  const editorState = _this._latestEditorState,\n        { data } = e\n  \n  if(!data) {\n    return\n  }\n\n  const selection = editorState.getSelection(),\n        inlineStyle = editorState.getInlineStyle(),\n        chars = data\n  \n  if(!selection.collapsed()) {\n    // e.preventDefault()\n    // _this.sync(\n    //   replaceChars(\n    //     editorState,\n    //     chars,\n    //     inlineStyle\n    //     /* true */\n    //   )\n    // )\n    // return\n  }\n \n  let newEditorState = replaceChars(\n    editorState,\n    chars,\n    inlineStyle\n    /* false */\n  )\n  \n  let preventDefault = false\n  \n  // if(!preventDefault) {}\n\n  // if(preventDefault) {\n  //   e.preventDefault()\n  //   _this.sync(newEditorState)\n  //   return\n  // }\n\n  _this._pendingEditorState = newEditorState\n}\n\nfunction replaceChars(\n  editorState: EditorState,\n  chars: string,\n  inlineStyle: InlineStyle\n  /* forceSelection: boolean */\n): EditorState {\n  const content = modifier.replaceChars(\n    editorState.getContent(),\n    editorState.getSelection(),\n    chars,\n    inlineStyle\n  )\n\n  // return EditorState.push(\n  //   editorState,\n  //   content,\n  //   forceSelection\n  //   'insert-chars'\n  // )\n  \n  const editorStateOptions = {\n    content: content,\n    selection: content.getSelectionAfter()\n    // forceSelection,\n    // changeType    \n  }\n\n  return EditorState.set(editorState, editorStateOptions)\n}\n\nmodule.exports = onBeforeInput\n                         \n","// @flow\n'use strict';\n\nconst Editor = require('Editor')\nconst asserts = require('asserts')\nconst findOffsetKey = require('findOffsetKey')\nconst DOMModifier = require('DOMModifier')\n\n// function onInput(\n//   _this: Editor,\n//   e: SyntheticInputEvent\n// ): void {}\n\nfunction onInput(\n  _this: Editor,\n  e: ?SyntheticInputEvent<>\n): void {\n  console.log('INPUT')\n  \n  if(_this._pendingEditorState != undefined) {\n    _this.sync(_this._pendingEditorState)\n    _this._pendingEditorState = undefined\n  }\n  \n  const editorState = _this._latestEditorState,\n        content = editorState.getContent()\n  \n  const rawSelection = DOMModifier.getSelection(_this.editor),\n        { anchorNode, anchorOffset, isCollapsed } = rawSelection,\n        domText = anchorNode.textContent\n\n  const anchorKeys = asserts(findOffsetKey(anchorNode, _this.editor), 'Null node'),\n        { start, end } = editorState\n        .getTree(anchorKeys.blockKey)\n        .getIn([\n          anchorKeys.decoratorKey,\n          'leaves',\n          anchorKeys.leafKey\n        ])\n  \n  const anchorBlock = content.getBlockForKey(anchorKeys.blockKey),\n        modelText = anchorBlock.getText().slice(start, end)    \n\n  console.log(DOMModifier.getSelection(_this.editor))\n  \n  // _this._latestEditorstate, _this.props.editorState\n  if(domText == modelText) {\n    const inputType = e ? e.nativeEvent.inputType : undefined\n    if(inputType) {}\n    return\n  }\n}\n\nmodule.exports = onInput\n","// @flow\n'use strict';\n\n// const backspace = require('backspace')\nconst keyMap = require('keyMap')\nconst keys = require('keys')\nconst Editor = require('Editor')\n\nfunction onKeyDown(\n  _this: Editor,\n  e: SyntheticKeyboardEvent<HTMLElement>\n): void {\n  const { keyMap } = _this.props,\n        { key, keyCode } = e\n\n  // space, return\n  switch(keyCode) {\n  case keys.RETURN:\n  case keys.SPACE:\n    console.log('space')\n    e.preventDefault()\n    break;\n  default:\n    break;\n  }\n  \n  const command = keyMap(e)\n  if(!command) {\n    return \n  }\n\n  e.preventDefault()\n\n  // top-level\n  // const { handler } = _this.props\n\n  const { editorState } = _this.props,\n        newEditorState = handle(command, editorState)\n  \n  if(editorState != newEditorState) {\n    _this.sync(newEditorState)\n  }\n}\n\nfunction handle(\n  command: string,\n  editorState: EditorState\n): EditorState {\n  switch(command) {\n  case 'backspace':\n    console.log('backspace')\n    // return backspace(editorstate)\n    return editorState\n  default:\n    return editorState\n  }\n}\n\nmodule.exports = onKeyDown\n","// @flow\n'use strict';\n\nconst asserts = require('asserts')\nconst getCastSelection = require('getCastSelection')\nconst castSelection = require('castSelection')\nconst EditorState = require('EditorState')\nconst Editor = require('Editor')\n\ntype DOMSelection = {\n  anchorNode: ?Node,\n  anchorOffset: number,\n  focusNode: ?Node,\n  focusOffset: number\n}\n\nfunction onSelect(_this: Editor): void {\n  console.log('SELECT')\n  // debugger;\n  \n  const { editorState } = _this.props\n  \n  if(_this._blockSelectEvent ||\n     _this._latestEditorState !== _this.props.editorState) {\n    return\n  }\n  \n  const selection = getCastSelection(editorState, getContentEditable(_this))\n  \n  let newEditorState: EditorState\n\n  if(selection !== editorState.getSelection()) {\n    newEditorState = editorState.acceptSelection(selection)    \n    _this.sync(newEditorState)\n  }\n}\n\nfunction getContentEditable(_this: Editor): ?HTMLElement {\n  const container: ?HTMLElement = _this.editorContainer\n  asserts(isHTMLElement(container), 'Container is invalid HTMLElement')\n  \n  return (container.firstChild: any)\n}\n\nfunction isHTMLElement(node: Element) {\n  return true\n}\n\nmodule.exports = onSelect\n","// @flow\n'use strict';\n\nconst keys = require('keys')\n\nfunction keyMap(e: KeyboardEvent): /* KeyCommand */ ?string {\n  const { keyCode, ctrlKey } = e\n  \n  switch(keyCode) {\n  case keys.BACKSPACE:\n    return 'backspace';\n  case keys.B:\n    return ctrlKey ? 'backspace' : null \n  default:\n    return null\n  }\n}\n\nmodule.exports = keyMap\n","'use strict';\n\nconst keys = {\n  BACKSPACE: 8,\n  TAB: 9,\n  RETURN: 13,\n  ESC: 27,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n  SPACE: 32,\n  B: 66,\n  D: 68,\n  H: 72,\n  I: 73,\n  J: 74,\n  K: 75,\n  M: 77,\n  O: 79,\n  T: 84,\n  U: 85,\n  W: 87,\n  Y: 89,\n  Z: 90\n}\n\nmodule.exports = keys\n","// @flow\n'use strict';\n\nconst EditorState = require('EditorState')\nconst SelectionState = require('SelectionState')\n\nfunction castSelection(\n  editorState: EditorState,\n  anchorKeys: ?{ [ key: string ]: string },\n  anchorOffset: number,\n  focusKeys: ?{ [ key: string ]: string },\n  focusOffset: number\n): SelectionState {\n  const selection = editorState.getSelection()\n\n  if(!anchorKeys || !focusKeys) {\n    return selection\n  }\n  \n  const anchorTree = editorState.getTree(anchorKeys.blockKey),\n        anchorLeaf = anchorTree.getIn([\n          anchorKeys.decoratorKey,\n          'leaves',\n          anchorKeys.leafKey\n        ])\n\n  const focusTree = editorState.getTree(focusKeys.blockKey),\n        focusLeaf = focusTree.getIn([\n          focusKeys.decoratorKey,\n          'leaves',\n          focusKeys.leafKey\n        ])\n\n  if(!anchorLeaf || !focusLeaf) {\n    return selection\n  }\n\n  const anchorLeafStart = anchorLeaf.get('start'),\n        anchorBlockOffset = anchorLeafStart + anchorOffset,\n        focusLeafStart = focusLeaf.get('start'),\n        focusBlockOffset = focusLeafStart + focusOffset\n\n  if(selection.get('anchorKey') == anchorKeys.blockKey &&\n     selection.get('anchorOffset') == anchorBlockOffset &&\n     selection.get('focusKey') == focusKeys.blockKey &&\n     selection.get('focusOffset') == focusBlockOffset) {\n    return selection\n  }\n\n  return selection.merge({\n    anchorKey: anchorKeys.blockKey,\n    anchorOffset: anchorBlockOffset,\n    focusKey: focusKeys.blockKey,\n    focusOffset: focusBlockOffset\n  })\n}\n\nmodule.exports = castSelection\n","// @flow\n'use strict';\n\nconst keyUtil = require('keyUtil')\nconst getOffsetKey = require('getOffsetKey')\n\nfunction findOffsetKey(\n  node: Node,\n  root: ?HTMLElement\n): ?{ [ key: string ]: string } {\n  let key, paren = node\n\n  while(paren && paren != root) {\n    key = getOffsetKey(paren)\n    \n    if(key) {\n      return keyUtil.decodin(key)\n    }\n\n    paren = paren.parentNode\n  }\n\n  return null\n}\n\nmodule.exports = findOffsetKey\n","// @flow\n'use strict';\n\nconst castSelection = require('castSelection')\nconst asserts = require('asserts')\nconst findOffsetKey = require('findOffsetKey')\nconst DOMModifier = require('DOMModifier')\nconst EditorState = require('EditorState')\nconst SelectionState = require('SelectionState')\n\nfunction getCastSelection(\n  editorState: EditorState,\n  root: ?HTMLElement\n): SelectionState {\n  //debugger;\n  const rawSelection: DOMSelection =  DOMModifier.getSelection(root),\n        { anchorNode, anchorOffset, focusNode, focusOffset, rangeCount } = rawSelection,\n        selection = editorState.getSelection()\n\n  if(rangeCount == 0 ||\n     anchorNode == null ||\n     focusNode == null) {\n    return selection\n  }\n\n  const anchorIsTextNode = anchorNode.nodeType == Node.TEXT_NODE,\n        focusIsTextNode = focusNode.nodeType == Node.TEXT_NODE\n\n  if(anchorIsTextNode && focusIsTextNode) {\n    return castSelection(\n      editorState,\n      asserts(findOffsetKey(anchorNode, root), 'Null node'),\n      anchorOffset,\n      asserts(findOffsetKey(focusNode, root), 'Null node'),\n      focusOffset\n    )\n  }\n\n  if(anchorIsTextNode) {\n    \n  } else if(focusIsTextNode) {\n\n  } else {\n    \n  }\n}\n\nmodule.exports = getCastSelection\n","// @flow\n'use strict';\n\nfunction getOffsetKey(node: Node): ?string {\n  if(isElement(node)) {\n    const castNode: Element = (node: any),\n          key = castNode.getAttribute('data-offset-key')\n    \n    if(key) {\n      return key\n    }\n\n    // for(...)\n  }\n  \n  return null\n}\n\nfunction isElement(node: ?Node): boolean {\n  if (!node || !node.ownerDocument) {\n    return false;\n  }\n  return node.nodeType === Node.ELEMENT_NODE;\n}\n\nmodule.exports = getOffsetKey\n","'use strict';\n\nconst styleMap = {\n  BOLD: {fontWeight: 'bold'},\n  ITALIC: {fontStyle: 'italic'},\n  CODE: { fontFamily: 'monospace', wordWrap: 'break-word'},\n  UNDERLINE: {textDecoration: 'underline'},\n  LINETHROUGH: {textDecoration: 'line-through'},\n}\n\nstyleMap.BOLD_ITALIC = { ...styleMap.BOLD, ...styleMap.ITALIC }\n\nmodule.exports = styleMap\n","// @flow\n\nconst asserts = require('asserts')\nconst findRange = require('findRange')\nconst ContentState = require('ContentState')\nconst ContentBlock = require('ContentBlock')\nconst {List, Repeat} = require('immutable')\n\ntype DecoratorOptions = {\n  strategy: Function,\n  component: Function,\n  props?: ?Object\n}\n\nclass Decorator {\n  _decorators: $ReadOnlyArray<DecoratorOptions>\n\n  constructor(decorators: $ReadOnlyArray<DecoratorOptions>) {\n    this._decorators = decorators\n  }\n\n  getDecorations(block: ContentBlock, content: ContentState): List<string> {\n    const list = Array(block.getText().length).fill(null)\n    \n    this.decorators.forEach((options, index) => {\n      const {strategy} = options\n      let counts = 0\n\n      // [,,'0.0','0.0','0.1','0.1']\n      function checker(start, end) {\n        if(canFill(list, start, end)) {\n          fill(list, start, end, index + DELIMITER + counts++)\n        }\n      }\n\n      strategy(block, checker, content)\n    })\n\n    return List(list)\n  }\n\n  getComponentForKey(key: string) {\n    asserts(!!key, \"Decorator key error: %s\", key)\n    \n    const index = parseInt(key.split(DELIMITER)[0]),\n          component = this.decorators[index].component\n\n    return typeof component == \"function\" ? component : null\n  }\n\n  getPropsForKey(key: string) {\n    const index = parseInt(key.split(DELIMITER)[0])\n          props = this.decorators[index].props\n\n    return props\n  }\n\n  get decorators(): $ReadOnlyArray<DecoratorOptions> {\n    return this._decorators\n  }\n}\n\nfunction canFill(list: Array<?string>, start: number, end: numebr): boolean {\n  for(let i=start; i<end; i++) {\n    if(list[i] != null) return false\n  }\n  return true\n}\n\nfunction fill(\n  list: Arrray<?string>,\n  start: number,\n  end: number,\n  key: string\n): void {\n  for(let i=start; i<end; i++) {\n    list[i]=key\n  }\n}\n\nconst DELIMITER = '.'\n\nmodule.exports = Decorator\n","// @flow\n'use strict';\n\nimport type {InlineStyle} from 'InlineStyle'\nconst {Record, Map, OrderedSet} = require('immutable')\n\ntype CharMetaValueType = InineStyle | ?string\n\ntype CharMetaConfig = {\n  style?: CharMetaValueType,\n  entity?: CharMetaValueType\n}\n\nconst EMPTYSET = OrderedSet()\nconst defaultConfig: CharMetaConfig = {\n  style: EMPTYSET,\n  entity: null\n}\n\nconst CharMetaRecord = (Record(defaultConfig):any)\n\nclass CharMeta extends CharMetaRecord {\n  static EMPTY: CharMeta\n\n  static create(config: CharMetaConfig): CharMeta {\n    if(!config) {\n      return EMPTY\n    }\n    \n    const map = Map(defaultConfig).merge(config),\n          copy = pool.get(map)\n    \n    if(copy) {\n      return copy\n    }\n\n    const charMeta = new CharMeta(config)\n    pool = pool.set(map, charMeta)\n    return charMeta\n  }\n\n  getStyle(): InlineStyle {\n    return this.get('style')\n  }\n\n  getEntity(): ?string {\n    return this.get('entity')\n  }\n}\n\nconst EMPTY = new CharMeta()\n\nlet pool: Map<Map<any, any>, CharMeta> = Map([\n  [Map(defaultConfig), EMPTY]\n])\n\nCharMeta.EMPTY = EMPTY\n\nmodule.exports = CharMeta\n","// @flow\n'use strict';\n\nimport type {InlineStyle} from 'InlineStyle'\nconst CharMeta = require('CharMeta')\nconst {Record, List} = require('immutable')\n\nexport type ContentBlockConfig = {\n  key: string,\n  type: string, //BlockType\n  text: string,\n  charMetas: List<CharMeta>\n}\n\nconst defaultConfig: ContentBlockConfig = {\n  key: '',\n  type: 'unstyled',\n  text: '',\n  charMetas: List(new CharMeta())\n}\n\nconst ContentBlockRecord = (Record(defaultConfig):any)\n\nclass ContentBlock extends ContentBlockRecord {\n  getKey(): string {\n    return this.get('key')\n  }\n\n  getType(): string {\n    return this.get('type')\n  }\n  \n  getText(): string {\n    return this.get('text')\n  }\n\n  getCharMetas(): List<CharMeta> {\n    return this.get('charMetas')\n  }\n\n  getStyleAt(offset: numeber): InlineStyle {\n    const charMeta:CharMeta = this.getCharMetas().get(offset)\n    return charMeta.getStyle()\n  }\n}\n\nmodule.exports = ContentBlock\n","// @flow\n'use strict';\n\nimport type {ContentBlockConfig} from 'ContentBlock'\nconst ContentBlock = require('ContentBlock')\nconst SelectionState = require('SelectionState')\nconst CharMeta = require('CharMeta')\nconst keyUtil = require('keyUtil')\nconst {Record, OrderedMap, List, Repeat} = require('immutable')\n\ntype ContentStateConfig = {\n  blockMap: ?OrderedMap<string, ContentBlock>,\n  selectionBefore: ?SelectionState,\n  selectionAfter: ?SelectionState\n  // entityMap\n}\n\nconst defaultConfig: ContentStateConfig = {\n  blockMap: null,\n  selectionBefore: null,\n  selectionAfter: null\n}\n\nconst ContentStateRecord = (Record(defaultConfig):any)\n\nclass ContentState extends ContentStateRecord {\n  static createWithText(\n    text: string,\n    delimiter: string | RegExp = /\\r\\n?|\\n/g\n  ): ContentState {\n    const strings = text.split(delimiter)\n    const blocks = strings.map(string => ({\n      key: keyUtil.random(),\n      type: 'unstyled',\n      text: string,\n      charMetas: List(Repeat(CharMeta.EMPTY, string.length))\n    }))\n    \n    return ContentState.createWithArray(blocks)\n  }\n\n  static createWithArray(blocks: Array<ContentBlockConfig>): ContentState {\n    const blockMap = OrderedMap(\n      blocks.map(block=>[block.key, new ContentBlock(block)])\n    )\n\n    const selection = blockMap.isEmpty()\n          ? new SelectionState()\n          : SelectionState.createEmpty(blockMap.first().getKey())\n    \n    return new ContentState({\n      blockMap: blockMap,\n      selectionBefore: selection,\n      selectionAfter: selection\n    })\n  }\n  \n  getBlockMap(): OrderedMap<string, ContentBlock> {\n    return this.get('blockMap')\n  }\n\n  getBlockForKey(key: string): ContentBlock {\n    return this.getBlockMap().get(key)\n  }\n\n  getSelectionBefore(): SelectionState {\n    return this.get('selectionBefore')\n  }\n\n  getSelectionAfter(): SelectionState {\n    return this.get('selectionAfter')\n  }\n  \n  findEntity() {}\n}\n\nmodule.exports = ContentState\n","// @flow\n'use strict';\n\nimport type {InlineStyle} from 'InlineStyle'\nconst ContentState = require('ContentState')\nconst SelectionState = require('SelectionState')\nconst Decorator = require('Decorator')\nconst ContentBlock = require('ContentBlock')\nconst Tree = require('Tree')\nconst {List, OrderedMap, Record} = require('immutable')\n\ntype EditorStateConfig = {\n  content: ?ContentState,\n  selection: ?SelectionState,\n  decorator: ?Decorator,\n  treeMap: ?OrderedMap<string, List<any>>\n  // undo: Stack, selectionBefore beforeinput changeType\n  // redo: Stack\n}\n\ntype EditorStateBaseConfig = {\n  content?: ?ContentState,\n  selection?: ?SelectionState,\n  decorator?: ?Decorator,\n  treeMap?: ?OrderedMap<string, List<any>>\n}\n\ntype EditorStateCreateConfig = {\n  ...EditorStateBaseConfig,\n  content: ContentState\n}\n\ntype EditorStateChangeConfig = {\n  ...EditorStateBaseConfig\n}\n\nconst defaultConfig: EditorStateConfig = {\n  content: null,\n  selection: null,\n  decorator: null,\n  treeMap: null\n}\n\nconst EditorStateRecord = (Record(defaultConfig):any)\n\nclass EditorState {\n  _immu: EditorStateRecord\n\n  constructor(immu: EditorStateRecord) {\n    this._immu = immu\n  }\n  \n  static create(config: EditorStateCreateConfig): EditorState {\n    const {content, decorator} = config\n    const withConfig = {\n      ...config,\n      treeMap: newTreeMap(content, decorator)\n    }\n\n    return new EditorState(EditorStateRecord(withConfig))\n  }\n  \n  static createWithText(text: string, decorator?: Decorator): EditorState {\n    const content = ContentState.createWithText(text),\n          key = content.getBlockMap().first().getKey()\n\n    return EditorState.create({\n      content: content,\n      selection: SelectionState.createEmpty(key),\n      decorator: decorator || null\n    })\n  }\n\n  static createEmpty(decorator?: Decorator): EditorState {\n    return EditorState.createWithText('', decorator)\n  }\n\n  // static createWithContent(content: Contentstate): EditorState {}\n\n  static set(\n    editorState: EditorState,\n    options: EditorStateChangeConfig\n  ): EditorState {\n    const record = editorState.immu.withMutations(map => {\n      const { selection, decorator } = options\n      \n      const content = options.content || editorState.getContent()\n\n      // ?new treeMap with decorator\n      \n      if(content != editorState.getContent()) {\n        map.merge({\n          treeMap: renewTreeMap(editorState, content, decorator)\n        })\n      }\n      \n      map.merge(options)\n    })\n \n    return new EditorState(record)\n  }\n\n  // static push\n  \n  acceptSelection(selection: SelectionState): EditorState {\n    return  EditorState.set(this, { selection: selection })\n  }\n  \n  getContent(): ContentState {\n    return this.immu.get('content')\n  }\n\n  getSelection(): SelectionState {\n    return this.immu.get('selection')\n  }\n\n  getDecorator(): Decorator {\n    return this.immu.get('decorator')\n  }\n\n  getTreeMap(): OrderedMap<string, List<any>> {\n    return this.immu.get('treeMap')\n  }\n\n  getTree(key: string): List<any> {\n    return this.getTreeMap().get(key)\n  }\n  \n  getInlineStyle(): InlineStyle {\n    const selection = this.getSelection(),\n          content = this.getContent()\n    \n    // if(selection.isCollapsed())\n    return this.getInlineStyleCollapsed(content, selection)\n  }\n\n  getInlineStyleCollapsed(\n    content: ContentState,\n    selection: SelectionState\n  ): InlineStyle {\n    const block = content.getBlockForKey(selection.getAnchorKey())\n    return block.getStyleAt(selection.getAnchorOffset()-1)\n  }\n\n  // getInlinestyleNonCollapsed\n  \n  get immu(): EditorStateRecord {\n    return this._immu\n  }\n}\n\nfunction newTreeMap(\n  content: ContentState,\n  decorator: ?Decorator\n): OrderedMap<string, List<any>> {\n  return content\n    .getBlockMap()\n    .map((block, key) => Tree.new(block, content, decorator))\n    .toOrderedMap()\n}\n\nfunction renewTreeMap(\n  editorState,\n  content,\n  decorator\n): OrderedMap<string, List<any>> {\n  const oldContent = editorState.getContent(),\n        oldBlockMap = oldContent.getBlockMap(),\n        newBlockMap = content.getBlockMap()\n   \n  return editorState.getTreeMap().merge(\n    newBlockMap\n      .toSeq()\n      .filter((block, key) => block != oldBlockMap.get(key))\n      .map(block => Tree.new(block, content, decorator))\n  )\n}\n\nmodule.exports = EditorState\n","// @flow\n'use strict';\n\nconst {Record} = require('immutable')\n\ntype SelectionStateConfig = {\n  anchorKey: ?string,\n  anchorOffset: ?number,\n  focusKey: ?string,\n  focusOffset: ?number\n  // backward\n}\n\nconst defaultConfig: SelectionStateConfig = {\n  anchorKey: null,\n  anchorOffset: null,\n  focusKey: null,\n  focusOffset: null\n}\n\nconst SelectionStateRecord = (Record(defaultConfig):any)\n\nclass SelectionState extends SelectionStateRecord {\n  static createEmpty(key: string): SelectionState {\n    return new SelectionState({\n      anchorKey: key,\n      anchorOffset: 0,\n      focusKey: key,\n      focusOffset: 0,\n    })\n  }\n\n  getAnchorKey(): string {\n    return this.get('anchorKey')\n  }\n\n  getAnchorOffset(): number {\n    return this.get('anchorOffset')\n  }\n\n  getFocusKey(): string {\n    return this.get('focusKey')\n  }\n\n  getFocusOffset(): number {\n    return this.get('focusOffset')\n  }\n\n  collapsed(): boolean {\n    return this.getAnchorKey() == this.getFocusKey() &&\n      this.getAnchorOffset() == this.getFocusOffset()\n  }\n\n  // backward(): boolean {}\n}\n\nmodule.exports = SelectionState\n","// @flow\n'use strict';\n\nconst findRange = require('findRange')\nconst ContentState = require('ContentState')\nconst ContentBlock = require('ContentBlock')\nconst CharMeta = require('CharMeta')\nconst Decorator = require('Decorator')\nconst {Record, List, Repeat} = require('immutable')\n\ntype LeafRangeConfig = {\n  start: ?number,\n  end: ?number\n}\n\nconst defaultLeaf: LeafRangeConfig= {\n  start: null,\n  end: null\n}\n\nconst LeafRange = (Record(defaultLeaf):any)\n\ntype BlockRangeConfig = {\n  start: ?number,\n  end: ?number,\n  decoratorKey: ?string,\n  // $FlowFixMe[value-as-type]  \n  leaves: ?List<LeafRange>\n}\n\nconst defaultBlock: BlockRangeConfig = {\n  start: null,\n  end: null,\n  decoratorKey: null,\n  leaves: null\n}\n\nconst BlockRange = (Record(defaultBlock):any)\n\nfunction findBlock(decorations: List<string>, block: ContentBlock): List<BlockRange> {\n  const charMetas = block.get('charMetas')\n  let ranges = []\n\n  findRange(decorations, equal, filter, (start, end) => {\n    ranges.push(new BlockRange({\n      start,\n      end,\n      decoratorKey: decorations.get(start),\n      leaves: findLeaf(charMetas.slice(start, end), start)\n    }))\n  })\n  \n  return List(ranges)\n}\n\nfunction findLeaf(charMetas: List<CharMeta>, offset: number): List<LeafRange> {\n  const inlineStyles = charMetas.map(charMeta => charMeta.getStyle()).toList()\n  let ranges = []\n  \n  findRange(inlineStyles, equal, filter, (start, end) => {\n    ranges.push(new LeafRange({\n      start: offset+start,\n      end: offset+end\n    }))\n  }\n)\n  return List(ranges)\n}\n\nconst equal = (a:any, b:any):boolean => a==b,\n      filter = (a:any):boolean => !0;\n\nconst Tree = {\n  new: (\n    block: ContentBlock,\n    content: ContentState,\n    decorator: ?Decorator\n  ): List<BlockRange> => {\n    const text = block.getText()\n \n   if(!text.length) {\n      return List.of(new BlockRange({\n        start: 0,\n        end: 0,\n        decoratorKey: null,\n        leaves: List.of(new LeafRange({start:0, end:0}))\n      }))\n    }\n\n    const decorations = decorator ? decorator.getDecorations(block, content)\n          : List(Repeat(null, text.length))\n\n    return findBlock(decorations, block)   \n  }\n}\n\nmodule.exports = Tree\n","// @flow\n'use strict';\n\nconst {List} = require('immutable')\n\nfunction findRange(\n  list: List<any>,\n  equal: (a:any, b:any)=>boolean,\n  filter: (a:any)=>boolean,\n  callback: (start:number, end:number)=>void\n):void {\n  if(list.isEmpty()) {\n    return\n  }\n\n  let cursor=0\n  \n  // reduce(function(total, currentValue, currentIndex, arr), initialValue)\n  list.reduce((total, currentValue, currentIndex) => {\n    if(!equal(total, currentValue)) {\n      if(filter(total)) {\n        callback(cursor, currentIndex)\n      }\n      cursor = currentIndex\n    }\n    return currentValue\n  })\n  \n  if(filter(list.last())) {\n    callback(cursor, list.count())\n  }\n}\n\nmodule.exports = findRange\n","'use strict';\n\nconst DOMmodifier = {\n  getSelection: function(node) {\n    // debugger;\n    const document = node.ownerDocument\n    return document.defaultView.getSelection()\n  }\n}\n\nmodule.exports = DOMmodifier\n","// @flow\n'use strict';\n\nimport type {InlineStyle} from 'InlineStyle'\n\nconst insertToList = require('insertToList')\nconst EditorState = require('EditorState')\nconst ContentState = require('ContentState')\nconst CharMeta = require('CharMeta')\nconst { List, Repeat } = require('immutable')\n\nconst modifier = {\n  replaceChars(\n    content: ContentState,\n    selection: SelectionState,\n    chars: string,\n    inlineStyle: InlineStyle\n  ): ContentState {\n    const startKey = selection.getAnchorKey(),\n          startOffset = selection.getAnchorOffset(),\n          block = content.getBlockForKey(startKey),\n          text = block.getText()\n\n    if(!selection.collapsed()) {}\n\n    const charMeta = CharMeta.create({\n      style: inlineStyle || OrderedSet()\n      // entityKey\n    })\n\n    const newBlock = block.merge({\n      text: text.slice(0, startOffset)\n        + chars\n        + text.slice(startOffset, text.length),\n      charMetas: insertToList(\n        block.getCharMetas(),\n        Repeat(charMeta, chars.length).toList(),\n        startOffset\n      )\n    })\n\n    const newOffset = startOffset + chars.length\n    \n    return content.merge({\n      blockMap: content.getBlockMap().set(startKey, newBlock),\n      selectionBefore: selection,\n      selectionAfter: selection.merge({\n        anchorOffset: newOffset,\n        focusOffset: newOffset\n      })\n      // entityMap\n    })\n  }\n}\n\n\nmodule.exports = modifier\n","// @flow\n'use strict';\n\nfunction insertToList(\n  list: List<T>,\n  partial: List<T>,\n  offset: number\n): List<T> {\n  let _list = list\n\n  if(offset == 0) {\n    partial.reverse().forEach(e => {\n      _list = _list.unshift(e)\n    })\n  } else if(offset == list.count()) {\n    partial.forEach(e => {\n      _list = _list.push(e)\n    })\n  } else {\n    let before = list.slice(0, offset),\n        after = list.slice(offset)\n\n    _list = before.concat(partial, after)\n  }\n  \n  return _list\n}\n\nmodule.exports = insertToList\n","'use strict'\n\nconst Editor = require('Editor')\nconst EditorState = require('EditorState')\nconst Decorator = require('Decorator')\nconst sfd = {\n  Editor,\n  EditorState,\n  Decorator\n}\n\nmodule.exports = sfd\n","'use strict';\n\nfunction asserts(predicate, format, ...args) {\n  let error = 'Error';\n  \n  if(format) {\n    let i = 0;\n    error = format.replace(/%s/g, function() { return args[i++] })\n  }\n\n  if(!predicate) {\n    throw new Error(error)\n  }\n\n  return predicate\n}\n\nmodule.exports = asserts\n","'use strict';\n\nconst MULTIPLIER = Math.pow(2,24)\nconst DELIMITER = '-'\nlet keys = []\n\nconst keyUtil = {\n  random: function() {\n    let key;\n    while(!key || keys.hasOwnProperty(key) && !isNaN(key)) {\n      key = Math.floor(Math.random()*MULTIPLIER).toString(32)\n    }\n    keys[key]=true\n    return key\n  },\n\n  encodin: function(key1, key2, key3) {\n    return [key1, key2, key3].join(DELIMITER)\n  },\n\n  decodin: function(key) {\n    const [key1, key2, key3] = key.split(DELIMITER)\n\n    return  key1 == key ? null : {\n      blockKey: key1,\n      decoratorKey: key2,\n      leafKey: key3\n    }\n  }\n}\n\nmodule.exports = keyUtil\n","/**\n * MIT License\n * \n * Copyright (c) 2014-present, Lee Byron and other contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar DELETE = 'delete';\n\n// Constants describing the size of trie nodes.\nvar SHIFT = 5; // Resulted in best performance after ______?\nvar SIZE = 1 << SHIFT;\nvar MASK = SIZE - 1;\n\n// A consistent shared value representing \"not set\" which equals nothing other\n// than itself, and nothing that could be provided externally.\nvar NOT_SET = {};\n\n// Boolean references, Rough equivalent of `bool &`.\nfunction MakeRef() {\n  return { value: false };\n}\n\nfunction SetRef(ref) {\n  if (ref) {\n    ref.value = true;\n  }\n}\n\n// A function which returns a value representing an \"owner\" for transient writes\n// to tries. The return value will only ever equal itself, and will not equal\n// the return of any subsequent call of this function.\nfunction OwnerID() {}\n\nfunction ensureSize(iter) {\n  if (iter.size === undefined) {\n    iter.size = iter.__iterate(returnTrue);\n  }\n  return iter.size;\n}\n\nfunction wrapIndex(iter, index) {\n  // This implements \"is array index\" which the ECMAString spec defines as:\n  //\n  //     A String property name P is an array index if and only if\n  //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n  //     to 2^321.\n  //\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n  if (typeof index !== 'number') {\n    var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n    if ('' + uint32Index !== index || uint32Index === 4294967295) {\n      return NaN;\n    }\n    index = uint32Index;\n  }\n  return index < 0 ? ensureSize(iter) + index : index;\n}\n\nfunction returnTrue() {\n  return true;\n}\n\nfunction wholeSlice(begin, end, size) {\n  return (\n    ((begin === 0 && !isNeg(begin)) ||\n      (size !== undefined && begin <= -size)) &&\n    (end === undefined || (size !== undefined && end >= size))\n  );\n}\n\nfunction resolveBegin(begin, size) {\n  return resolveIndex(begin, size, 0);\n}\n\nfunction resolveEnd(end, size) {\n  return resolveIndex(end, size, size);\n}\n\nfunction resolveIndex(index, size, defaultIndex) {\n  // Sanitize indices using this shorthand for ToInt32(argument)\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n  return index === undefined\n    ? defaultIndex\n    : isNeg(index)\n    ? size === Infinity\n      ? size\n      : Math.max(0, size + index) | 0\n    : size === undefined || size === index\n    ? index\n    : Math.min(size, index) | 0;\n}\n\nfunction isNeg(value) {\n  // Account for -0 which is negative, but not less than 0.\n  return value < 0 || (value === 0 && 1 / value === -Infinity);\n}\n\nvar IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';\n\nfunction isCollection(maybeCollection) {\n  return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);\n}\n\nvar IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';\n\nfunction isKeyed(maybeKeyed) {\n  return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);\n}\n\nvar IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';\n\nfunction isIndexed(maybeIndexed) {\n  return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);\n}\n\nfunction isAssociative(maybeAssociative) {\n  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n}\n\nvar Collection = function Collection(value) {\n  return isCollection(value) ? value : Seq(value);\n};\n\nvar KeyedCollection = /*@__PURE__*/(function (Collection) {\n  function KeyedCollection(value) {\n    return isKeyed(value) ? value : KeyedSeq(value);\n  }\n\n  if ( Collection ) KeyedCollection.__proto__ = Collection;\n  KeyedCollection.prototype = Object.create( Collection && Collection.prototype );\n  KeyedCollection.prototype.constructor = KeyedCollection;\n\n  return KeyedCollection;\n}(Collection));\n\nvar IndexedCollection = /*@__PURE__*/(function (Collection) {\n  function IndexedCollection(value) {\n    return isIndexed(value) ? value : IndexedSeq(value);\n  }\n\n  if ( Collection ) IndexedCollection.__proto__ = Collection;\n  IndexedCollection.prototype = Object.create( Collection && Collection.prototype );\n  IndexedCollection.prototype.constructor = IndexedCollection;\n\n  return IndexedCollection;\n}(Collection));\n\nvar SetCollection = /*@__PURE__*/(function (Collection) {\n  function SetCollection(value) {\n    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n  }\n\n  if ( Collection ) SetCollection.__proto__ = Collection;\n  SetCollection.prototype = Object.create( Collection && Collection.prototype );\n  SetCollection.prototype.constructor = SetCollection;\n\n  return SetCollection;\n}(Collection));\n\nCollection.Keyed = KeyedCollection;\nCollection.Indexed = IndexedCollection;\nCollection.Set = SetCollection;\n\nvar IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';\n\nfunction isSeq(maybeSeq) {\n  return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);\n}\n\nvar IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';\n\nfunction isRecord(maybeRecord) {\n  return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);\n}\n\nfunction isImmutable(maybeImmutable) {\n  return isCollection(maybeImmutable) || isRecord(maybeImmutable);\n}\n\nvar IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';\n\nfunction isOrdered(maybeOrdered) {\n  return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);\n}\n\nvar ITERATE_KEYS = 0;\nvar ITERATE_VALUES = 1;\nvar ITERATE_ENTRIES = 2;\n\nvar REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nvar ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\nvar Iterator = function Iterator(next) {\n  this.next = next;\n};\n\nIterator.prototype.toString = function toString () {\n  return '[Iterator]';\n};\n\nIterator.KEYS = ITERATE_KEYS;\nIterator.VALUES = ITERATE_VALUES;\nIterator.ENTRIES = ITERATE_ENTRIES;\n\nIterator.prototype.inspect = Iterator.prototype.toSource = function () {\n  return this.toString();\n};\nIterator.prototype[ITERATOR_SYMBOL] = function () {\n  return this;\n};\n\nfunction iteratorValue(type, k, v, iteratorResult) {\n  var value = type === 0 ? k : type === 1 ? v : [k, v];\n  iteratorResult\n    ? (iteratorResult.value = value)\n    : (iteratorResult = {\n        value: value,\n        done: false,\n      });\n  return iteratorResult;\n}\n\nfunction iteratorDone() {\n  return { value: undefined, done: true };\n}\n\nfunction hasIterator(maybeIterable) {\n  if (Array.isArray(maybeIterable)) {\n    // IE11 trick as it does not support `Symbol.iterator`\n    return true;\n  }\n\n  return !!getIteratorFn(maybeIterable);\n}\n\nfunction isIterator(maybeIterator) {\n  return maybeIterator && typeof maybeIterator.next === 'function';\n}\n\nfunction getIterator(iterable) {\n  var iteratorFn = getIteratorFn(iterable);\n  return iteratorFn && iteratorFn.call(iterable);\n}\n\nfunction getIteratorFn(iterable) {\n  var iteratorFn =\n    iterable &&\n    ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]);\n  if (typeof iteratorFn === 'function') {\n    return iteratorFn;\n  }\n}\n\nfunction isEntriesIterable(maybeIterable) {\n  var iteratorFn = getIteratorFn(maybeIterable);\n  return iteratorFn && iteratorFn === maybeIterable.entries;\n}\n\nfunction isKeysIterable(maybeIterable) {\n  var iteratorFn = getIteratorFn(maybeIterable);\n  return iteratorFn && iteratorFn === maybeIterable.keys;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isArrayLike(value) {\n  if (Array.isArray(value) || typeof value === 'string') {\n    return true;\n  }\n\n  return (\n    value &&\n    typeof value === 'object' &&\n    Number.isInteger(value.length) &&\n    value.length >= 0 &&\n    (value.length === 0\n      ? // Only {length: 0} is considered Array-like.\n        Object.keys(value).length === 1\n      : // An object is only Array-like if it has a property where the last value\n        // in the array-like may be found (which could be undefined).\n        value.hasOwnProperty(value.length - 1))\n  );\n}\n\nvar Seq = /*@__PURE__*/(function (Collection) {\n  function Seq(value) {\n    return value === null || value === undefined\n      ? emptySequence()\n      : isImmutable(value)\n      ? value.toSeq()\n      : seqFromValue(value);\n  }\n\n  if ( Collection ) Seq.__proto__ = Collection;\n  Seq.prototype = Object.create( Collection && Collection.prototype );\n  Seq.prototype.constructor = Seq;\n\n  Seq.prototype.toSeq = function toSeq () {\n    return this;\n  };\n\n  Seq.prototype.toString = function toString () {\n    return this.__toString('Seq {', '}');\n  };\n\n  Seq.prototype.cacheResult = function cacheResult () {\n    if (!this._cache && this.__iterateUncached) {\n      this._cache = this.entrySeq().toArray();\n      this.size = this._cache.length;\n    }\n    return this;\n  };\n\n  // abstract __iterateUncached(fn, reverse)\n\n  Seq.prototype.__iterate = function __iterate (fn, reverse) {\n    var cache = this._cache;\n    if (cache) {\n      var size = cache.length;\n      var i = 0;\n      while (i !== size) {\n        var entry = cache[reverse ? size - ++i : i++];\n        if (fn(entry[1], entry[0], this) === false) {\n          break;\n        }\n      }\n      return i;\n    }\n    return this.__iterateUncached(fn, reverse);\n  };\n\n  // abstract __iteratorUncached(type, reverse)\n\n  Seq.prototype.__iterator = function __iterator (type, reverse) {\n    var cache = this._cache;\n    if (cache) {\n      var size = cache.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var entry = cache[reverse ? size - ++i : i++];\n        return iteratorValue(type, entry[0], entry[1]);\n      });\n    }\n    return this.__iteratorUncached(type, reverse);\n  };\n\n  return Seq;\n}(Collection));\n\nvar KeyedSeq = /*@__PURE__*/(function (Seq) {\n  function KeyedSeq(value) {\n    return value === null || value === undefined\n      ? emptySequence().toKeyedSeq()\n      : isCollection(value)\n      ? isKeyed(value)\n        ? value.toSeq()\n        : value.fromEntrySeq()\n      : isRecord(value)\n      ? value.toSeq()\n      : keyedSeqFromValue(value);\n  }\n\n  if ( Seq ) KeyedSeq.__proto__ = Seq;\n  KeyedSeq.prototype = Object.create( Seq && Seq.prototype );\n  KeyedSeq.prototype.constructor = KeyedSeq;\n\n  KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {\n    return this;\n  };\n\n  return KeyedSeq;\n}(Seq));\n\nvar IndexedSeq = /*@__PURE__*/(function (Seq) {\n  function IndexedSeq(value) {\n    return value === null || value === undefined\n      ? emptySequence()\n      : isCollection(value)\n      ? isKeyed(value)\n        ? value.entrySeq()\n        : value.toIndexedSeq()\n      : isRecord(value)\n      ? value.toSeq().entrySeq()\n      : indexedSeqFromValue(value);\n  }\n\n  if ( Seq ) IndexedSeq.__proto__ = Seq;\n  IndexedSeq.prototype = Object.create( Seq && Seq.prototype );\n  IndexedSeq.prototype.constructor = IndexedSeq;\n\n  IndexedSeq.of = function of (/*...values*/) {\n    return IndexedSeq(arguments);\n  };\n\n  IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {\n    return this;\n  };\n\n  IndexedSeq.prototype.toString = function toString () {\n    return this.__toString('Seq [', ']');\n  };\n\n  return IndexedSeq;\n}(Seq));\n\nvar SetSeq = /*@__PURE__*/(function (Seq) {\n  function SetSeq(value) {\n    return (\n      isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)\n    ).toSetSeq();\n  }\n\n  if ( Seq ) SetSeq.__proto__ = Seq;\n  SetSeq.prototype = Object.create( Seq && Seq.prototype );\n  SetSeq.prototype.constructor = SetSeq;\n\n  SetSeq.of = function of (/*...values*/) {\n    return SetSeq(arguments);\n  };\n\n  SetSeq.prototype.toSetSeq = function toSetSeq () {\n    return this;\n  };\n\n  return SetSeq;\n}(Seq));\n\nSeq.isSeq = isSeq;\nSeq.Keyed = KeyedSeq;\nSeq.Set = SetSeq;\nSeq.Indexed = IndexedSeq;\n\nSeq.prototype[IS_SEQ_SYMBOL] = true;\n\n// #pragma Root Sequences\n\nvar ArraySeq = /*@__PURE__*/(function (IndexedSeq) {\n  function ArraySeq(array) {\n    this._array = array;\n    this.size = array.length;\n  }\n\n  if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;\n  ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  ArraySeq.prototype.constructor = ArraySeq;\n\n  ArraySeq.prototype.get = function get (index, notSetValue) {\n    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n  };\n\n  ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {\n    var array = this._array;\n    var size = array.length;\n    var i = 0;\n    while (i !== size) {\n      var ii = reverse ? size - ++i : i++;\n      if (fn(array[ii], ii, this) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  ArraySeq.prototype.__iterator = function __iterator (type, reverse) {\n    var array = this._array;\n    var size = array.length;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var ii = reverse ? size - ++i : i++;\n      return iteratorValue(type, ii, array[ii]);\n    });\n  };\n\n  return ArraySeq;\n}(IndexedSeq));\n\nvar ObjectSeq = /*@__PURE__*/(function (KeyedSeq) {\n  function ObjectSeq(object) {\n    var keys = Object.keys(object);\n    this._object = object;\n    this._keys = keys;\n    this.size = keys.length;\n  }\n\n  if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;\n  ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n  ObjectSeq.prototype.constructor = ObjectSeq;\n\n  ObjectSeq.prototype.get = function get (key, notSetValue) {\n    if (notSetValue !== undefined && !this.has(key)) {\n      return notSetValue;\n    }\n    return this._object[key];\n  };\n\n  ObjectSeq.prototype.has = function has (key) {\n    return hasOwnProperty.call(this._object, key);\n  };\n\n  ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {\n    var object = this._object;\n    var keys = this._keys;\n    var size = keys.length;\n    var i = 0;\n    while (i !== size) {\n      var key = keys[reverse ? size - ++i : i++];\n      if (fn(object[key], key, this) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {\n    var object = this._object;\n    var keys = this._keys;\n    var size = keys.length;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var key = keys[reverse ? size - ++i : i++];\n      return iteratorValue(type, key, object[key]);\n    });\n  };\n\n  return ObjectSeq;\n}(KeyedSeq));\nObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;\n\nvar CollectionSeq = /*@__PURE__*/(function (IndexedSeq) {\n  function CollectionSeq(collection) {\n    this._collection = collection;\n    this.size = collection.length || collection.size;\n  }\n\n  if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;\n  CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  CollectionSeq.prototype.constructor = CollectionSeq;\n\n  CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var collection = this._collection;\n    var iterator = getIterator(collection);\n    var iterations = 0;\n    if (isIterator(iterator)) {\n      var step;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n    }\n    return iterations;\n  };\n\n  CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var collection = this._collection;\n    var iterator = getIterator(collection);\n    if (!isIterator(iterator)) {\n      return new Iterator(iteratorDone);\n    }\n    var iterations = 0;\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done ? step : iteratorValue(type, iterations++, step.value);\n    });\n  };\n\n  return CollectionSeq;\n}(IndexedSeq));\n\n// # pragma Helper functions\n\nvar EMPTY_SEQ;\n\nfunction emptySequence() {\n  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n}\n\nfunction keyedSeqFromValue(value) {\n  var seq = maybeIndexedSeqFromValue(value);\n  if (seq) {\n    return seq.fromEntrySeq();\n  }\n  if (typeof value === 'object') {\n    return new ObjectSeq(value);\n  }\n  throw new TypeError(\n    'Expected Array or collection object of [k, v] entries, or keyed object: ' +\n      value\n  );\n}\n\nfunction indexedSeqFromValue(value) {\n  var seq = maybeIndexedSeqFromValue(value);\n  if (seq) {\n    return seq;\n  }\n  throw new TypeError(\n    'Expected Array or collection object of values: ' + value\n  );\n}\n\nfunction seqFromValue(value) {\n  var seq = maybeIndexedSeqFromValue(value);\n  if (seq) {\n    return isEntriesIterable(value)\n      ? seq.fromEntrySeq()\n      : isKeysIterable(value)\n      ? seq.toSetSeq()\n      : seq;\n  }\n  if (typeof value === 'object') {\n    return new ObjectSeq(value);\n  }\n  throw new TypeError(\n    'Expected Array or collection object of values, or keyed object: ' + value\n  );\n}\n\nfunction maybeIndexedSeqFromValue(value) {\n  return isArrayLike(value)\n    ? new ArraySeq(value)\n    : hasIterator(value)\n    ? new CollectionSeq(value)\n    : undefined;\n}\n\nvar IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';\n\nfunction isMap(maybeMap) {\n  return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);\n}\n\nfunction isOrderedMap(maybeOrderedMap) {\n  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n}\n\nfunction isValueObject(maybeValue) {\n  return Boolean(\n    maybeValue &&\n      typeof maybeValue.equals === 'function' &&\n      typeof maybeValue.hashCode === 'function'\n  );\n}\n\n/**\n * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n *\n * NaN is considered the same as NaN, however -0 and 0 are considered the same\n * value, which is different from the algorithm described by\n * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n *\n * This is extended further to allow Objects to describe the values they\n * represent, by way of `valueOf` or `equals` (and `hashCode`).\n *\n * Note: because of this extension, the key equality of Immutable.Map and the\n * value equality of Immutable.Set will differ from ES6 Map and Set.\n *\n * ### Defining custom values\n *\n * The easiest way to describe the value an object represents is by implementing\n * `valueOf`. For example, `Date` represents a value by returning a unix\n * timestamp for `valueOf`:\n *\n *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n *     var date2 = new Date(1234567890000);\n *     date1.valueOf(); // 1234567890000\n *     assert( date1 !== date2 );\n *     assert( Immutable.is( date1, date2 ) );\n *\n * Note: overriding `valueOf` may have other implications if you use this object\n * where JavaScript expects a primitive, such as implicit string coercion.\n *\n * For more complex types, especially collections, implementing `valueOf` may\n * not be performant. An alternative is to implement `equals` and `hashCode`.\n *\n * `equals` takes another object, presumably of similar type, and returns true\n * if it is equal. Equality is symmetrical, so the same result should be\n * returned if this and the argument are flipped.\n *\n *     assert( a.equals(b) === b.equals(a) );\n *\n * `hashCode` returns a 32bit integer number representing the object which will\n * be used to determine how to store the value object in a Map or Set. You must\n * provide both or neither methods, one must not exist without the other.\n *\n * Also, an important relationship between these methods must be upheld: if two\n * values are equal, they *must* return the same hashCode. If the values are not\n * equal, they might have the same hashCode; this is called a hash collision,\n * and while undesirable for performance reasons, it is acceptable.\n *\n *     if (a.equals(b)) {\n *       assert( a.hashCode() === b.hashCode() );\n *     }\n *\n * All Immutable collections are Value Objects: they implement `equals()`\n * and `hashCode()`.\n */\nfunction is(valueA, valueB) {\n  if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n    return true;\n  }\n  if (!valueA || !valueB) {\n    return false;\n  }\n  if (\n    typeof valueA.valueOf === 'function' &&\n    typeof valueB.valueOf === 'function'\n  ) {\n    valueA = valueA.valueOf();\n    valueB = valueB.valueOf();\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n  }\n  return !!(\n    isValueObject(valueA) &&\n    isValueObject(valueB) &&\n    valueA.equals(valueB)\n  );\n}\n\nvar imul =\n  typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2\n    ? Math.imul\n    : function imul(a, b) {\n        a |= 0; // int\n        b |= 0; // int\n        var c = a & 0xffff;\n        var d = b & 0xffff;\n        // Shift by 0 fixes the sign on the high part.\n        return (c * d + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0)) | 0; // int\n      };\n\n// v8 has an optimization for storing 31-bit signed numbers.\n// Values which have either 00 or 11 as the high order bits qualify.\n// This function drops the highest order bit in a signed number, maintaining\n// the sign bit.\nfunction smi(i32) {\n  return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);\n}\n\nvar defaultValueOf = Object.prototype.valueOf;\n\nfunction hash(o) {\n  if (o == null) {\n    return hashNullish(o);\n  }\n\n  if (typeof o.hashCode === 'function') {\n    // Drop any high bits from accidentally long hash codes.\n    return smi(o.hashCode(o));\n  }\n\n  var v = valueOf(o);\n\n  if (v == null) {\n    return hashNullish(v);\n  }\n\n  switch (typeof v) {\n    case 'boolean':\n      // The hash values for built-in constants are a 1 value for each 5-byte\n      // shift region expect for the first, which encodes the value. This\n      // reduces the odds of a hash collision for these common values.\n      return v ? 0x42108421 : 0x42108420;\n    case 'number':\n      return hashNumber(v);\n    case 'string':\n      return v.length > STRING_HASH_CACHE_MIN_STRLEN\n        ? cachedHashString(v)\n        : hashString(v);\n    case 'object':\n    case 'function':\n      return hashJSObj(v);\n    case 'symbol':\n      return hashSymbol(v);\n    default:\n      if (typeof v.toString === 'function') {\n        return hashString(v.toString());\n      }\n      throw new Error('Value type ' + typeof v + ' cannot be hashed.');\n  }\n}\n\nfunction hashNullish(nullish) {\n  return nullish === null ? 0x42108422 : /* undefined */ 0x42108423;\n}\n\n// Compress arbitrarily large numbers into smi hashes.\nfunction hashNumber(n) {\n  if (n !== n || n === Infinity) {\n    return 0;\n  }\n  var hash = n | 0;\n  if (hash !== n) {\n    hash ^= n * 0xffffffff;\n  }\n  while (n > 0xffffffff) {\n    n /= 0xffffffff;\n    hash ^= n;\n  }\n  return smi(hash);\n}\n\nfunction cachedHashString(string) {\n  var hashed = stringHashCache[string];\n  if (hashed === undefined) {\n    hashed = hashString(string);\n    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n      STRING_HASH_CACHE_SIZE = 0;\n      stringHashCache = {};\n    }\n    STRING_HASH_CACHE_SIZE++;\n    stringHashCache[string] = hashed;\n  }\n  return hashed;\n}\n\n// http://jsperf.com/hashing-strings\nfunction hashString(string) {\n  // This is the hash from JVM\n  // The hash code for a string is computed as\n  // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n  // where s[i] is the ith character of the string and n is the length of\n  // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n  // (exclusive) by dropping high bits.\n  var hashed = 0;\n  for (var ii = 0; ii < string.length; ii++) {\n    hashed = (31 * hashed + string.charCodeAt(ii)) | 0;\n  }\n  return smi(hashed);\n}\n\nfunction hashSymbol(sym) {\n  var hashed = symbolMap[sym];\n  if (hashed !== undefined) {\n    return hashed;\n  }\n\n  hashed = nextHash();\n\n  symbolMap[sym] = hashed;\n\n  return hashed;\n}\n\nfunction hashJSObj(obj) {\n  var hashed;\n  if (usingWeakMap) {\n    hashed = weakMap.get(obj);\n    if (hashed !== undefined) {\n      return hashed;\n    }\n  }\n\n  hashed = obj[UID_HASH_KEY];\n  if (hashed !== undefined) {\n    return hashed;\n  }\n\n  if (!canDefineProperty) {\n    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n    if (hashed !== undefined) {\n      return hashed;\n    }\n\n    hashed = getIENodeHash(obj);\n    if (hashed !== undefined) {\n      return hashed;\n    }\n  }\n\n  hashed = nextHash();\n\n  if (usingWeakMap) {\n    weakMap.set(obj, hashed);\n  } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n    throw new Error('Non-extensible objects are not allowed as keys.');\n  } else if (canDefineProperty) {\n    Object.defineProperty(obj, UID_HASH_KEY, {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: hashed,\n    });\n  } else if (\n    obj.propertyIsEnumerable !== undefined &&\n    obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable\n  ) {\n    // Since we can't define a non-enumerable property on the object\n    // we'll hijack one of the less-used non-enumerable properties to\n    // save our hash on it. Since this is a function it will not show up in\n    // `JSON.stringify` which is what we want.\n    obj.propertyIsEnumerable = function () {\n      return this.constructor.prototype.propertyIsEnumerable.apply(\n        this,\n        arguments\n      );\n    };\n    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;\n  } else if (obj.nodeType !== undefined) {\n    // At this point we couldn't get the IE `uniqueID` to use as a hash\n    // and we couldn't use a non-enumerable property to exploit the\n    // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n    // itself.\n    obj[UID_HASH_KEY] = hashed;\n  } else {\n    throw new Error('Unable to set a non-enumerable property on object.');\n  }\n\n  return hashed;\n}\n\n// Get references to ES5 object methods.\nvar isExtensible = Object.isExtensible;\n\n// True if Object.defineProperty works as expected. IE8 fails this test.\nvar canDefineProperty = (function () {\n  try {\n    Object.defineProperty({}, '@', {});\n    return true;\n  } catch (e) {\n    return false;\n  }\n})();\n\n// IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n// and avoid memory leaks from the IE cloneNode bug.\nfunction getIENodeHash(node) {\n  if (node && node.nodeType > 0) {\n    switch (node.nodeType) {\n      case 1: // Element\n        return node.uniqueID;\n      case 9: // Document\n        return node.documentElement && node.documentElement.uniqueID;\n    }\n  }\n}\n\nfunction valueOf(obj) {\n  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === 'function'\n    ? obj.valueOf(obj)\n    : obj;\n}\n\nfunction nextHash() {\n  var nextHash = ++_objHashUID;\n  if (_objHashUID & 0x40000000) {\n    _objHashUID = 0;\n  }\n  return nextHash;\n}\n\n// If possible, use a WeakMap.\nvar usingWeakMap = typeof WeakMap === 'function';\nvar weakMap;\nif (usingWeakMap) {\n  weakMap = new WeakMap();\n}\n\nvar symbolMap = Object.create(null);\n\nvar _objHashUID = 0;\n\nvar UID_HASH_KEY = '__immutablehash__';\nif (typeof Symbol === 'function') {\n  UID_HASH_KEY = Symbol(UID_HASH_KEY);\n}\n\nvar STRING_HASH_CACHE_MIN_STRLEN = 16;\nvar STRING_HASH_CACHE_MAX_SIZE = 255;\nvar STRING_HASH_CACHE_SIZE = 0;\nvar stringHashCache = {};\n\nvar ToKeyedSequence = /*@__PURE__*/(function (KeyedSeq) {\n  function ToKeyedSequence(indexed, useKeys) {\n    this._iter = indexed;\n    this._useKeys = useKeys;\n    this.size = indexed.size;\n  }\n\n  if ( KeyedSeq ) ToKeyedSequence.__proto__ = KeyedSeq;\n  ToKeyedSequence.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n  ToKeyedSequence.prototype.constructor = ToKeyedSequence;\n\n  ToKeyedSequence.prototype.get = function get (key, notSetValue) {\n    return this._iter.get(key, notSetValue);\n  };\n\n  ToKeyedSequence.prototype.has = function has (key) {\n    return this._iter.has(key);\n  };\n\n  ToKeyedSequence.prototype.valueSeq = function valueSeq () {\n    return this._iter.valueSeq();\n  };\n\n  ToKeyedSequence.prototype.reverse = function reverse () {\n    var this$1$1 = this;\n\n    var reversedSequence = reverseFactory(this, true);\n    if (!this._useKeys) {\n      reversedSequence.valueSeq = function () { return this$1$1._iter.toSeq().reverse(); };\n    }\n    return reversedSequence;\n  };\n\n  ToKeyedSequence.prototype.map = function map (mapper, context) {\n    var this$1$1 = this;\n\n    var mappedSequence = mapFactory(this, mapper, context);\n    if (!this._useKeys) {\n      mappedSequence.valueSeq = function () { return this$1$1._iter.toSeq().map(mapper, context); };\n    }\n    return mappedSequence;\n  };\n\n  ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    return this._iter.__iterate(function (v, k) { return fn(v, k, this$1$1); }, reverse);\n  };\n\n  ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {\n    return this._iter.__iterator(type, reverse);\n  };\n\n  return ToKeyedSequence;\n}(KeyedSeq));\nToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;\n\nvar ToIndexedSequence = /*@__PURE__*/(function (IndexedSeq) {\n  function ToIndexedSequence(iter) {\n    this._iter = iter;\n    this.size = iter.size;\n  }\n\n  if ( IndexedSeq ) ToIndexedSequence.__proto__ = IndexedSeq;\n  ToIndexedSequence.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  ToIndexedSequence.prototype.constructor = ToIndexedSequence;\n\n  ToIndexedSequence.prototype.includes = function includes (value) {\n    return this._iter.includes(value);\n  };\n\n  ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    var i = 0;\n    reverse && ensureSize(this);\n    return this._iter.__iterate(\n      function (v) { return fn(v, reverse ? this$1$1.size - ++i : i++, this$1$1); },\n      reverse\n    );\n  };\n\n  ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var this$1$1 = this;\n\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    var i = 0;\n    reverse && ensureSize(this);\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done\n        ? step\n        : iteratorValue(\n            type,\n            reverse ? this$1$1.size - ++i : i++,\n            step.value,\n            step\n          );\n    });\n  };\n\n  return ToIndexedSequence;\n}(IndexedSeq));\n\nvar ToSetSequence = /*@__PURE__*/(function (SetSeq) {\n  function ToSetSequence(iter) {\n    this._iter = iter;\n    this.size = iter.size;\n  }\n\n  if ( SetSeq ) ToSetSequence.__proto__ = SetSeq;\n  ToSetSequence.prototype = Object.create( SetSeq && SetSeq.prototype );\n  ToSetSequence.prototype.constructor = ToSetSequence;\n\n  ToSetSequence.prototype.has = function has (key) {\n    return this._iter.includes(key);\n  };\n\n  ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    return this._iter.__iterate(function (v) { return fn(v, v, this$1$1); }, reverse);\n  };\n\n  ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done\n        ? step\n        : iteratorValue(type, step.value, step.value, step);\n    });\n  };\n\n  return ToSetSequence;\n}(SetSeq));\n\nvar FromEntriesSequence = /*@__PURE__*/(function (KeyedSeq) {\n  function FromEntriesSequence(entries) {\n    this._iter = entries;\n    this.size = entries.size;\n  }\n\n  if ( KeyedSeq ) FromEntriesSequence.__proto__ = KeyedSeq;\n  FromEntriesSequence.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n  FromEntriesSequence.prototype.constructor = FromEntriesSequence;\n\n  FromEntriesSequence.prototype.entrySeq = function entrySeq () {\n    return this._iter.toSeq();\n  };\n\n  FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    return this._iter.__iterate(function (entry) {\n      // Check if entry exists first so array access doesn't throw for holes\n      // in the parent iteration.\n      if (entry) {\n        validateEntry(entry);\n        var indexedCollection = isCollection(entry);\n        return fn(\n          indexedCollection ? entry.get(1) : entry[1],\n          indexedCollection ? entry.get(0) : entry[0],\n          this$1$1\n        );\n      }\n    }, reverse);\n  };\n\n  FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    return new Iterator(function () {\n      while (true) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return iteratorValue(\n            type,\n            indexedCollection ? entry.get(0) : entry[0],\n            indexedCollection ? entry.get(1) : entry[1],\n            step\n          );\n        }\n      }\n    });\n  };\n\n  return FromEntriesSequence;\n}(KeyedSeq));\n\nToIndexedSequence.prototype.cacheResult =\n  ToKeyedSequence.prototype.cacheResult =\n  ToSetSequence.prototype.cacheResult =\n  FromEntriesSequence.prototype.cacheResult =\n    cacheResultThrough;\n\nfunction flipFactory(collection) {\n  var flipSequence = makeSequence(collection);\n  flipSequence._iter = collection;\n  flipSequence.size = collection.size;\n  flipSequence.flip = function () { return collection; };\n  flipSequence.reverse = function () {\n    var reversedSequence = collection.reverse.apply(this); // super.reverse()\n    reversedSequence.flip = function () { return collection.reverse(); };\n    return reversedSequence;\n  };\n  flipSequence.has = function (key) { return collection.includes(key); };\n  flipSequence.includes = function (key) { return collection.has(key); };\n  flipSequence.cacheResult = cacheResultThrough;\n  flipSequence.__iterateUncached = function (fn, reverse) {\n    var this$1$1 = this;\n\n    return collection.__iterate(function (v, k) { return fn(k, v, this$1$1) !== false; }, reverse);\n  };\n  flipSequence.__iteratorUncached = function (type, reverse) {\n    if (type === ITERATE_ENTRIES) {\n      var iterator = collection.__iterator(type, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (!step.done) {\n          var k = step.value[0];\n          step.value[0] = step.value[1];\n          step.value[1] = k;\n        }\n        return step;\n      });\n    }\n    return collection.__iterator(\n      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n      reverse\n    );\n  };\n  return flipSequence;\n}\n\nfunction mapFactory(collection, mapper, context) {\n  var mappedSequence = makeSequence(collection);\n  mappedSequence.size = collection.size;\n  mappedSequence.has = function (key) { return collection.has(key); };\n  mappedSequence.get = function (key, notSetValue) {\n    var v = collection.get(key, NOT_SET);\n    return v === NOT_SET\n      ? notSetValue\n      : mapper.call(context, v, key, collection);\n  };\n  mappedSequence.__iterateUncached = function (fn, reverse) {\n    var this$1$1 = this;\n\n    return collection.__iterate(\n      function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1$1) !== false; },\n      reverse\n    );\n  };\n  mappedSequence.__iteratorUncached = function (type, reverse) {\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      var key = entry[0];\n      return iteratorValue(\n        type,\n        key,\n        mapper.call(context, entry[1], key, collection),\n        step\n      );\n    });\n  };\n  return mappedSequence;\n}\n\nfunction reverseFactory(collection, useKeys) {\n  var this$1$1 = this;\n\n  var reversedSequence = makeSequence(collection);\n  reversedSequence._iter = collection;\n  reversedSequence.size = collection.size;\n  reversedSequence.reverse = function () { return collection; };\n  if (collection.flip) {\n    reversedSequence.flip = function () {\n      var flipSequence = flipFactory(collection);\n      flipSequence.reverse = function () { return collection.flip(); };\n      return flipSequence;\n    };\n  }\n  reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };\n  reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };\n  reversedSequence.includes = function (value) { return collection.includes(value); };\n  reversedSequence.cacheResult = cacheResultThrough;\n  reversedSequence.__iterate = function (fn, reverse) {\n    var this$1$1 = this;\n\n    var i = 0;\n    reverse && ensureSize(collection);\n    return collection.__iterate(\n      function (v, k) { return fn(v, useKeys ? k : reverse ? this$1$1.size - ++i : i++, this$1$1); },\n      !reverse\n    );\n  };\n  reversedSequence.__iterator = function (type, reverse) {\n    var i = 0;\n    reverse && ensureSize(collection);\n    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      return iteratorValue(\n        type,\n        useKeys ? entry[0] : reverse ? this$1$1.size - ++i : i++,\n        entry[1],\n        step\n      );\n    });\n  };\n  return reversedSequence;\n}\n\nfunction filterFactory(collection, predicate, context, useKeys) {\n  var filterSequence = makeSequence(collection);\n  if (useKeys) {\n    filterSequence.has = function (key) {\n      var v = collection.get(key, NOT_SET);\n      return v !== NOT_SET && !!predicate.call(context, v, key, collection);\n    };\n    filterSequence.get = function (key, notSetValue) {\n      var v = collection.get(key, NOT_SET);\n      return v !== NOT_SET && predicate.call(context, v, key, collection)\n        ? v\n        : notSetValue;\n    };\n  }\n  filterSequence.__iterateUncached = function (fn, reverse) {\n    var this$1$1 = this;\n\n    var iterations = 0;\n    collection.__iterate(function (v, k, c) {\n      if (predicate.call(context, v, k, c)) {\n        iterations++;\n        return fn(v, useKeys ? k : iterations - 1, this$1$1);\n      }\n    }, reverse);\n    return iterations;\n  };\n  filterSequence.__iteratorUncached = function (type, reverse) {\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var iterations = 0;\n    return new Iterator(function () {\n      while (true) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        var value = entry[1];\n        if (predicate.call(context, value, key, collection)) {\n          return iteratorValue(type, useKeys ? key : iterations++, value, step);\n        }\n      }\n    });\n  };\n  return filterSequence;\n}\n\nfunction countByFactory(collection, grouper, context) {\n  var groups = Map().asMutable();\n  collection.__iterate(function (v, k) {\n    groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });\n  });\n  return groups.asImmutable();\n}\n\nfunction groupByFactory(collection, grouper, context) {\n  var isKeyedIter = isKeyed(collection);\n  var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();\n  collection.__iterate(function (v, k) {\n    groups.update(\n      grouper.call(context, v, k, collection),\n      function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }\n    );\n  });\n  var coerce = collectionClass(collection);\n  return groups.map(function (arr) { return reify(collection, coerce(arr)); }).asImmutable();\n}\n\nfunction sliceFactory(collection, begin, end, useKeys) {\n  var originalSize = collection.size;\n\n  if (wholeSlice(begin, end, originalSize)) {\n    return collection;\n  }\n\n  var resolvedBegin = resolveBegin(begin, originalSize);\n  var resolvedEnd = resolveEnd(end, originalSize);\n\n  // begin or end will be NaN if they were provided as negative numbers and\n  // this collection's size is unknown. In that case, cache first so there is\n  // a known size and these do not resolve to NaN.\n  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n  }\n\n  // Note: resolvedEnd is undefined when the original sequence's length is\n  // unknown and this slice did not supply an end and should contain all\n  // elements after resolvedBegin.\n  // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n  var resolvedSize = resolvedEnd - resolvedBegin;\n  var sliceSize;\n  if (resolvedSize === resolvedSize) {\n    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n  }\n\n  var sliceSeq = makeSequence(collection);\n\n  // If collection.size is undefined, the size of the realized sliceSeq is\n  // unknown at this point unless the number of items to slice is 0\n  sliceSeq.size =\n    sliceSize === 0 ? sliceSize : (collection.size && sliceSize) || undefined;\n\n  if (!useKeys && isSeq(collection) && sliceSize >= 0) {\n    sliceSeq.get = function (index, notSetValue) {\n      index = wrapIndex(this, index);\n      return index >= 0 && index < sliceSize\n        ? collection.get(index + resolvedBegin, notSetValue)\n        : notSetValue;\n    };\n  }\n\n  sliceSeq.__iterateUncached = function (fn, reverse) {\n    var this$1$1 = this;\n\n    if (sliceSize === 0) {\n      return 0;\n    }\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var skipped = 0;\n    var isSkipping = true;\n    var iterations = 0;\n    collection.__iterate(function (v, k) {\n      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n        iterations++;\n        return (\n          fn(v, useKeys ? k : iterations - 1, this$1$1) !== false &&\n          iterations !== sliceSize\n        );\n      }\n    });\n    return iterations;\n  };\n\n  sliceSeq.__iteratorUncached = function (type, reverse) {\n    if (sliceSize !== 0 && reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    // Don't bother instantiating parent iterator if taking 0.\n    if (sliceSize === 0) {\n      return new Iterator(iteratorDone);\n    }\n    var iterator = collection.__iterator(type, reverse);\n    var skipped = 0;\n    var iterations = 0;\n    return new Iterator(function () {\n      while (skipped++ < resolvedBegin) {\n        iterator.next();\n      }\n      if (++iterations > sliceSize) {\n        return iteratorDone();\n      }\n      var step = iterator.next();\n      if (useKeys || type === ITERATE_VALUES || step.done) {\n        return step;\n      }\n      if (type === ITERATE_KEYS) {\n        return iteratorValue(type, iterations - 1, undefined, step);\n      }\n      return iteratorValue(type, iterations - 1, step.value[1], step);\n    });\n  };\n\n  return sliceSeq;\n}\n\nfunction takeWhileFactory(collection, predicate, context) {\n  var takeSequence = makeSequence(collection);\n  takeSequence.__iterateUncached = function (fn, reverse) {\n    var this$1$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterations = 0;\n    collection.__iterate(\n      function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1$1); }\n    );\n    return iterations;\n  };\n  takeSequence.__iteratorUncached = function (type, reverse) {\n    var this$1$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var iterating = true;\n    return new Iterator(function () {\n      if (!iterating) {\n        return iteratorDone();\n      }\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      var k = entry[0];\n      var v = entry[1];\n      if (!predicate.call(context, v, k, this$1$1)) {\n        iterating = false;\n        return iteratorDone();\n      }\n      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n    });\n  };\n  return takeSequence;\n}\n\nfunction skipWhileFactory(collection, predicate, context, useKeys) {\n  var skipSequence = makeSequence(collection);\n  skipSequence.__iterateUncached = function (fn, reverse) {\n    var this$1$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var isSkipping = true;\n    var iterations = 0;\n    collection.__iterate(function (v, k, c) {\n      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n        iterations++;\n        return fn(v, useKeys ? k : iterations - 1, this$1$1);\n      }\n    });\n    return iterations;\n  };\n  skipSequence.__iteratorUncached = function (type, reverse) {\n    var this$1$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var skipping = true;\n    var iterations = 0;\n    return new Iterator(function () {\n      var step;\n      var k;\n      var v;\n      do {\n        step = iterator.next();\n        if (step.done) {\n          if (useKeys || type === ITERATE_VALUES) {\n            return step;\n          }\n          if (type === ITERATE_KEYS) {\n            return iteratorValue(type, iterations++, undefined, step);\n          }\n          return iteratorValue(type, iterations++, step.value[1], step);\n        }\n        var entry = step.value;\n        k = entry[0];\n        v = entry[1];\n        skipping && (skipping = predicate.call(context, v, k, this$1$1));\n      } while (skipping);\n      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n    });\n  };\n  return skipSequence;\n}\n\nfunction concatFactory(collection, values) {\n  var isKeyedCollection = isKeyed(collection);\n  var iters = [collection]\n    .concat(values)\n    .map(function (v) {\n      if (!isCollection(v)) {\n        v = isKeyedCollection\n          ? keyedSeqFromValue(v)\n          : indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedCollection) {\n        v = KeyedCollection(v);\n      }\n      return v;\n    })\n    .filter(function (v) { return v.size !== 0; });\n\n  if (iters.length === 0) {\n    return collection;\n  }\n\n  if (iters.length === 1) {\n    var singleton = iters[0];\n    if (\n      singleton === collection ||\n      (isKeyedCollection && isKeyed(singleton)) ||\n      (isIndexed(collection) && isIndexed(singleton))\n    ) {\n      return singleton;\n    }\n  }\n\n  var concatSeq = new ArraySeq(iters);\n  if (isKeyedCollection) {\n    concatSeq = concatSeq.toKeyedSeq();\n  } else if (!isIndexed(collection)) {\n    concatSeq = concatSeq.toSetSeq();\n  }\n  concatSeq = concatSeq.flatten(true);\n  concatSeq.size = iters.reduce(function (sum, seq) {\n    if (sum !== undefined) {\n      var size = seq.size;\n      if (size !== undefined) {\n        return sum + size;\n      }\n    }\n  }, 0);\n  return concatSeq;\n}\n\nfunction flattenFactory(collection, depth, useKeys) {\n  var flatSequence = makeSequence(collection);\n  flatSequence.__iterateUncached = function (fn, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterations = 0;\n    var stopped = false;\n    function flatDeep(iter, currentDepth) {\n      iter.__iterate(function (v, k) {\n        if ((!depth || currentDepth < depth) && isCollection(v)) {\n          flatDeep(v, currentDepth + 1);\n        } else {\n          iterations++;\n          if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {\n            stopped = true;\n          }\n        }\n        return !stopped;\n      }, reverse);\n    }\n    flatDeep(collection, 0);\n    return iterations;\n  };\n  flatSequence.__iteratorUncached = function (type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(type, reverse);\n    var stack = [];\n    var iterations = 0;\n    return new Iterator(function () {\n      while (iterator) {\n        var step = iterator.next();\n        if (step.done !== false) {\n          iterator = stack.pop();\n          continue;\n        }\n        var v = step.value;\n        if (type === ITERATE_ENTRIES) {\n          v = v[1];\n        }\n        if ((!depth || stack.length < depth) && isCollection(v)) {\n          stack.push(iterator);\n          iterator = v.__iterator(type, reverse);\n        } else {\n          return useKeys ? step : iteratorValue(type, iterations++, v, step);\n        }\n      }\n      return iteratorDone();\n    });\n  };\n  return flatSequence;\n}\n\nfunction flatMapFactory(collection, mapper, context) {\n  var coerce = collectionClass(collection);\n  return collection\n    .toSeq()\n    .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })\n    .flatten(true);\n}\n\nfunction interposeFactory(collection, separator) {\n  var interposedSequence = makeSequence(collection);\n  interposedSequence.size = collection.size && collection.size * 2 - 1;\n  interposedSequence.__iterateUncached = function (fn, reverse) {\n    var this$1$1 = this;\n\n    var iterations = 0;\n    collection.__iterate(\n      function (v) { return (!iterations || fn(separator, iterations++, this$1$1) !== false) &&\n        fn(v, iterations++, this$1$1) !== false; },\n      reverse\n    );\n    return iterations;\n  };\n  interposedSequence.__iteratorUncached = function (type, reverse) {\n    var iterator = collection.__iterator(ITERATE_VALUES, reverse);\n    var iterations = 0;\n    var step;\n    return new Iterator(function () {\n      if (!step || iterations % 2) {\n        step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n      }\n      return iterations % 2\n        ? iteratorValue(type, iterations++, separator)\n        : iteratorValue(type, iterations++, step.value, step);\n    });\n  };\n  return interposedSequence;\n}\n\nfunction sortFactory(collection, comparator, mapper) {\n  if (!comparator) {\n    comparator = defaultComparator;\n  }\n  var isKeyedCollection = isKeyed(collection);\n  var index = 0;\n  var entries = collection\n    .toSeq()\n    .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })\n    .valueSeq()\n    .toArray();\n  entries\n    .sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; })\n    .forEach(\n      isKeyedCollection\n        ? function (v, i) {\n            entries[i].length = 2;\n          }\n        : function (v, i) {\n            entries[i] = v[1];\n          }\n    );\n  return isKeyedCollection\n    ? KeyedSeq(entries)\n    : isIndexed(collection)\n    ? IndexedSeq(entries)\n    : SetSeq(entries);\n}\n\nfunction maxFactory(collection, comparator, mapper) {\n  if (!comparator) {\n    comparator = defaultComparator;\n  }\n  if (mapper) {\n    var entry = collection\n      .toSeq()\n      .map(function (v, k) { return [v, mapper(v, k, collection)]; })\n      .reduce(function (a, b) { return (maxCompare(comparator, a[1], b[1]) ? b : a); });\n    return entry && entry[0];\n  }\n  return collection.reduce(function (a, b) { return (maxCompare(comparator, a, b) ? b : a); });\n}\n\nfunction maxCompare(comparator, a, b) {\n  var comp = comparator(b, a);\n  // b is considered the new max if the comparator declares them equal, but\n  // they are not equal and b is in fact a nullish value.\n  return (\n    (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) ||\n    comp > 0\n  );\n}\n\nfunction zipWithFactory(keyIter, zipper, iters, zipAll) {\n  var zipSequence = makeSequence(keyIter);\n  var sizes = new ArraySeq(iters).map(function (i) { return i.size; });\n  zipSequence.size = zipAll ? sizes.max() : sizes.min();\n  // Note: this a generic base implementation of __iterate in terms of\n  // __iterator which may be more generically useful in the future.\n  zipSequence.__iterate = function (fn, reverse) {\n    /* generic:\n    var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n    var step;\n    var iterations = 0;\n    while (!(step = iterator.next()).done) {\n      iterations++;\n      if (fn(step.value[1], step.value[0], this) === false) {\n        break;\n      }\n    }\n    return iterations;\n    */\n    // indexed:\n    var iterator = this.__iterator(ITERATE_VALUES, reverse);\n    var step;\n    var iterations = 0;\n    while (!(step = iterator.next()).done) {\n      if (fn(step.value, iterations++, this) === false) {\n        break;\n      }\n    }\n    return iterations;\n  };\n  zipSequence.__iteratorUncached = function (type, reverse) {\n    var iterators = iters.map(\n      function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }\n    );\n    var iterations = 0;\n    var isDone = false;\n    return new Iterator(function () {\n      var steps;\n      if (!isDone) {\n        steps = iterators.map(function (i) { return i.next(); });\n        isDone = zipAll ? steps.every(function (s) { return s.done; }) : steps.some(function (s) { return s.done; });\n      }\n      if (isDone) {\n        return iteratorDone();\n      }\n      return iteratorValue(\n        type,\n        iterations++,\n        zipper.apply(\n          null,\n          steps.map(function (s) { return s.value; })\n        )\n      );\n    });\n  };\n  return zipSequence;\n}\n\n// #pragma Helper Functions\n\nfunction reify(iter, seq) {\n  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n}\n\nfunction validateEntry(entry) {\n  if (entry !== Object(entry)) {\n    throw new TypeError('Expected [K, V] tuple: ' + entry);\n  }\n}\n\nfunction collectionClass(collection) {\n  return isKeyed(collection)\n    ? KeyedCollection\n    : isIndexed(collection)\n    ? IndexedCollection\n    : SetCollection;\n}\n\nfunction makeSequence(collection) {\n  return Object.create(\n    (isKeyed(collection)\n      ? KeyedSeq\n      : isIndexed(collection)\n      ? IndexedSeq\n      : SetSeq\n    ).prototype\n  );\n}\n\nfunction cacheResultThrough() {\n  if (this._iter.cacheResult) {\n    this._iter.cacheResult();\n    this.size = this._iter.size;\n    return this;\n  }\n  return Seq.prototype.cacheResult.call(this);\n}\n\nfunction defaultComparator(a, b) {\n  if (a === undefined && b === undefined) {\n    return 0;\n  }\n\n  if (a === undefined) {\n    return 1;\n  }\n\n  if (b === undefined) {\n    return -1;\n  }\n\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\nfunction arrCopy(arr, offset) {\n  offset = offset || 0;\n  var len = Math.max(0, arr.length - offset);\n  var newArr = new Array(len);\n  for (var ii = 0; ii < len; ii++) {\n    newArr[ii] = arr[ii + offset];\n  }\n  return newArr;\n}\n\nfunction invariant(condition, error) {\n  if (!condition) { throw new Error(error); }\n}\n\nfunction assertNotInfinite(size) {\n  invariant(\n    size !== Infinity,\n    'Cannot perform this action with an infinite size.'\n  );\n}\n\nfunction coerceKeyPath(keyPath) {\n  if (isArrayLike(keyPath) && typeof keyPath !== 'string') {\n    return keyPath;\n  }\n  if (isOrdered(keyPath)) {\n    return keyPath.toArray();\n  }\n  throw new TypeError(\n    'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath\n  );\n}\n\nvar toString = Object.prototype.toString;\n\nfunction isPlainObject(value) {\n  // The base prototype's toString deals with Argument objects and native namespaces like Math\n  if (\n    !value ||\n    typeof value !== 'object' ||\n    toString.call(value) !== '[object Object]'\n  ) {\n    return false;\n  }\n\n  var proto = Object.getPrototypeOf(value);\n  if (proto === null) {\n    return true;\n  }\n\n  // Iteratively going up the prototype chain is needed for cross-realm environments (differing contexts, iframes, etc)\n  var parentProto = proto;\n  var nextProto = Object.getPrototypeOf(proto);\n  while (nextProto !== null) {\n    parentProto = nextProto;\n    nextProto = Object.getPrototypeOf(parentProto);\n  }\n  return parentProto === proto;\n}\n\n/**\n * Returns true if the value is a potentially-persistent data structure, either\n * provided by Immutable.js or a plain Array or Object.\n */\nfunction isDataStructure(value) {\n  return (\n    typeof value === 'object' &&\n    (isImmutable(value) || Array.isArray(value) || isPlainObject(value))\n  );\n}\n\nfunction quoteString(value) {\n  try {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  } catch (_ignoreError) {\n    return JSON.stringify(value);\n  }\n}\n\nfunction has(collection, key) {\n  return isImmutable(collection)\n    ? collection.has(key)\n    : isDataStructure(collection) && hasOwnProperty.call(collection, key);\n}\n\nfunction get(collection, key, notSetValue) {\n  return isImmutable(collection)\n    ? collection.get(key, notSetValue)\n    : !has(collection, key)\n    ? notSetValue\n    : typeof collection.get === 'function'\n    ? collection.get(key)\n    : collection[key];\n}\n\nfunction shallowCopy(from) {\n  if (Array.isArray(from)) {\n    return arrCopy(from);\n  }\n  var to = {};\n  for (var key in from) {\n    if (hasOwnProperty.call(from, key)) {\n      to[key] = from[key];\n    }\n  }\n  return to;\n}\n\nfunction remove(collection, key) {\n  if (!isDataStructure(collection)) {\n    throw new TypeError(\n      'Cannot update non-data-structure value: ' + collection\n    );\n  }\n  if (isImmutable(collection)) {\n    if (!collection.remove) {\n      throw new TypeError(\n        'Cannot update immutable value without .remove() method: ' + collection\n      );\n    }\n    return collection.remove(key);\n  }\n  if (!hasOwnProperty.call(collection, key)) {\n    return collection;\n  }\n  var collectionCopy = shallowCopy(collection);\n  if (Array.isArray(collectionCopy)) {\n    collectionCopy.splice(key, 1);\n  } else {\n    delete collectionCopy[key];\n  }\n  return collectionCopy;\n}\n\nfunction set(collection, key, value) {\n  if (!isDataStructure(collection)) {\n    throw new TypeError(\n      'Cannot update non-data-structure value: ' + collection\n    );\n  }\n  if (isImmutable(collection)) {\n    if (!collection.set) {\n      throw new TypeError(\n        'Cannot update immutable value without .set() method: ' + collection\n      );\n    }\n    return collection.set(key, value);\n  }\n  if (hasOwnProperty.call(collection, key) && value === collection[key]) {\n    return collection;\n  }\n  var collectionCopy = shallowCopy(collection);\n  collectionCopy[key] = value;\n  return collectionCopy;\n}\n\nfunction updateIn$1(collection, keyPath, notSetValue, updater) {\n  if (!updater) {\n    updater = notSetValue;\n    notSetValue = undefined;\n  }\n  var updatedValue = updateInDeeply(\n    isImmutable(collection),\n    collection,\n    coerceKeyPath(keyPath),\n    0,\n    notSetValue,\n    updater\n  );\n  return updatedValue === NOT_SET ? notSetValue : updatedValue;\n}\n\nfunction updateInDeeply(\n  inImmutable,\n  existing,\n  keyPath,\n  i,\n  notSetValue,\n  updater\n) {\n  var wasNotSet = existing === NOT_SET;\n  if (i === keyPath.length) {\n    var existingValue = wasNotSet ? notSetValue : existing;\n    var newValue = updater(existingValue);\n    return newValue === existingValue ? existing : newValue;\n  }\n  if (!wasNotSet && !isDataStructure(existing)) {\n    throw new TypeError(\n      'Cannot update within non-data-structure value in path [' +\n        keyPath.slice(0, i).map(quoteString) +\n        ']: ' +\n        existing\n    );\n  }\n  var key = keyPath[i];\n  var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);\n  var nextUpdated = updateInDeeply(\n    nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),\n    nextExisting,\n    keyPath,\n    i + 1,\n    notSetValue,\n    updater\n  );\n  return nextUpdated === nextExisting\n    ? existing\n    : nextUpdated === NOT_SET\n    ? remove(existing, key)\n    : set(\n        wasNotSet ? (inImmutable ? emptyMap() : {}) : existing,\n        key,\n        nextUpdated\n      );\n}\n\nfunction setIn$1(collection, keyPath, value) {\n  return updateIn$1(collection, keyPath, NOT_SET, function () { return value; });\n}\n\nfunction setIn(keyPath, v) {\n  return setIn$1(this, keyPath, v);\n}\n\nfunction removeIn(collection, keyPath) {\n  return updateIn$1(collection, keyPath, function () { return NOT_SET; });\n}\n\nfunction deleteIn(keyPath) {\n  return removeIn(this, keyPath);\n}\n\nfunction update$1(collection, key, notSetValue, updater) {\n  return updateIn$1(collection, [key], notSetValue, updater);\n}\n\nfunction update(key, notSetValue, updater) {\n  return arguments.length === 1\n    ? key(this)\n    : update$1(this, key, notSetValue, updater);\n}\n\nfunction updateIn(keyPath, notSetValue, updater) {\n  return updateIn$1(this, keyPath, notSetValue, updater);\n}\n\nfunction merge$1() {\n  var iters = [], len = arguments.length;\n  while ( len-- ) iters[ len ] = arguments[ len ];\n\n  return mergeIntoKeyedWith(this, iters);\n}\n\nfunction mergeWith$1(merger) {\n  var iters = [], len = arguments.length - 1;\n  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n  if (typeof merger !== 'function') {\n    throw new TypeError('Invalid merger function: ' + merger);\n  }\n  return mergeIntoKeyedWith(this, iters, merger);\n}\n\nfunction mergeIntoKeyedWith(collection, collections, merger) {\n  var iters = [];\n  for (var ii = 0; ii < collections.length; ii++) {\n    var collection$1 = KeyedCollection(collections[ii]);\n    if (collection$1.size !== 0) {\n      iters.push(collection$1);\n    }\n  }\n  if (iters.length === 0) {\n    return collection;\n  }\n  if (\n    collection.toSeq().size === 0 &&\n    !collection.__ownerID &&\n    iters.length === 1\n  ) {\n    return collection.constructor(iters[0]);\n  }\n  return collection.withMutations(function (collection) {\n    var mergeIntoCollection = merger\n      ? function (value, key) {\n          update$1(collection, key, NOT_SET, function (oldVal) { return oldVal === NOT_SET ? value : merger(oldVal, value, key); }\n          );\n        }\n      : function (value, key) {\n          collection.set(key, value);\n        };\n    for (var ii = 0; ii < iters.length; ii++) {\n      iters[ii].forEach(mergeIntoCollection);\n    }\n  });\n}\n\nfunction merge(collection) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  return mergeWithSources(collection, sources);\n}\n\nfunction mergeWith(merger, collection) {\n  var sources = [], len = arguments.length - 2;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];\n\n  return mergeWithSources(collection, sources, merger);\n}\n\nfunction mergeDeep$1(collection) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  return mergeDeepWithSources(collection, sources);\n}\n\nfunction mergeDeepWith$1(merger, collection) {\n  var sources = [], len = arguments.length - 2;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];\n\n  return mergeDeepWithSources(collection, sources, merger);\n}\n\nfunction mergeDeepWithSources(collection, sources, merger) {\n  return mergeWithSources(collection, sources, deepMergerWith(merger));\n}\n\nfunction mergeWithSources(collection, sources, merger) {\n  if (!isDataStructure(collection)) {\n    throw new TypeError(\n      'Cannot merge into non-data-structure value: ' + collection\n    );\n  }\n  if (isImmutable(collection)) {\n    return typeof merger === 'function' && collection.mergeWith\n      ? collection.mergeWith.apply(collection, [ merger ].concat( sources ))\n      : collection.merge\n      ? collection.merge.apply(collection, sources)\n      : collection.concat.apply(collection, sources);\n  }\n  var isArray = Array.isArray(collection);\n  var merged = collection;\n  var Collection = isArray ? IndexedCollection : KeyedCollection;\n  var mergeItem = isArray\n    ? function (value) {\n        // Copy on write\n        if (merged === collection) {\n          merged = shallowCopy(merged);\n        }\n        merged.push(value);\n      }\n    : function (value, key) {\n        var hasVal = hasOwnProperty.call(merged, key);\n        var nextVal =\n          hasVal && merger ? merger(merged[key], value, key) : value;\n        if (!hasVal || nextVal !== merged[key]) {\n          // Copy on write\n          if (merged === collection) {\n            merged = shallowCopy(merged);\n          }\n          merged[key] = nextVal;\n        }\n      };\n  for (var i = 0; i < sources.length; i++) {\n    Collection(sources[i]).forEach(mergeItem);\n  }\n  return merged;\n}\n\nfunction deepMergerWith(merger) {\n  function deepMerger(oldValue, newValue, key) {\n    return isDataStructure(oldValue) &&\n      isDataStructure(newValue) &&\n      areMergeable(oldValue, newValue)\n      ? mergeWithSources(oldValue, [newValue], deepMerger)\n      : merger\n      ? merger(oldValue, newValue, key)\n      : newValue;\n  }\n  return deepMerger;\n}\n\n/**\n * It's unclear what the desired behavior is for merging two collections that\n * fall into separate categories between keyed, indexed, or set-like, so we only\n * consider them mergeable if they fall into the same category.\n */\nfunction areMergeable(oldDataStructure, newDataStructure) {\n  var oldSeq = Seq(oldDataStructure);\n  var newSeq = Seq(newDataStructure);\n  // This logic assumes that a sequence can only fall into one of the three\n  // categories mentioned above (since there's no `isSetLike()` method).\n  return (\n    isIndexed(oldSeq) === isIndexed(newSeq) &&\n    isKeyed(oldSeq) === isKeyed(newSeq)\n  );\n}\n\nfunction mergeDeep() {\n  var iters = [], len = arguments.length;\n  while ( len-- ) iters[ len ] = arguments[ len ];\n\n  return mergeDeepWithSources(this, iters);\n}\n\nfunction mergeDeepWith(merger) {\n  var iters = [], len = arguments.length - 1;\n  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n  return mergeDeepWithSources(this, iters, merger);\n}\n\nfunction mergeIn(keyPath) {\n  var iters = [], len = arguments.length - 1;\n  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n  return updateIn$1(this, keyPath, emptyMap(), function (m) { return mergeWithSources(m, iters); });\n}\n\nfunction mergeDeepIn(keyPath) {\n  var iters = [], len = arguments.length - 1;\n  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n  return updateIn$1(this, keyPath, emptyMap(), function (m) { return mergeDeepWithSources(m, iters); }\n  );\n}\n\nfunction withMutations(fn) {\n  var mutable = this.asMutable();\n  fn(mutable);\n  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n}\n\nfunction asMutable() {\n  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n}\n\nfunction asImmutable() {\n  return this.__ensureOwner();\n}\n\nfunction wasAltered() {\n  return this.__altered;\n}\n\nvar Map = /*@__PURE__*/(function (KeyedCollection) {\n  function Map(value) {\n    return value === null || value === undefined\n      ? emptyMap()\n      : isMap(value) && !isOrdered(value)\n      ? value\n      : emptyMap().withMutations(function (map) {\n          var iter = KeyedCollection(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function (v, k) { return map.set(k, v); });\n        });\n  }\n\n  if ( KeyedCollection ) Map.__proto__ = KeyedCollection;\n  Map.prototype = Object.create( KeyedCollection && KeyedCollection.prototype );\n  Map.prototype.constructor = Map;\n\n  Map.of = function of () {\n    var keyValues = [], len = arguments.length;\n    while ( len-- ) keyValues[ len ] = arguments[ len ];\n\n    return emptyMap().withMutations(function (map) {\n      for (var i = 0; i < keyValues.length; i += 2) {\n        if (i + 1 >= keyValues.length) {\n          throw new Error('Missing value for key: ' + keyValues[i]);\n        }\n        map.set(keyValues[i], keyValues[i + 1]);\n      }\n    });\n  };\n\n  Map.prototype.toString = function toString () {\n    return this.__toString('Map {', '}');\n  };\n\n  // @pragma Access\n\n  Map.prototype.get = function get (k, notSetValue) {\n    return this._root\n      ? this._root.get(0, undefined, k, notSetValue)\n      : notSetValue;\n  };\n\n  // @pragma Modification\n\n  Map.prototype.set = function set (k, v) {\n    return updateMap(this, k, v);\n  };\n\n  Map.prototype.remove = function remove (k) {\n    return updateMap(this, k, NOT_SET);\n  };\n\n  Map.prototype.deleteAll = function deleteAll (keys) {\n    var collection = Collection(keys);\n\n    if (collection.size === 0) {\n      return this;\n    }\n\n    return this.withMutations(function (map) {\n      collection.forEach(function (key) { return map.remove(key); });\n    });\n  };\n\n  Map.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._root = null;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyMap();\n  };\n\n  // @pragma Composition\n\n  Map.prototype.sort = function sort (comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator));\n  };\n\n  Map.prototype.sortBy = function sortBy (mapper, comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator, mapper));\n  };\n\n  Map.prototype.map = function map (mapper, context) {\n    var this$1$1 = this;\n\n    return this.withMutations(function (map) {\n      map.forEach(function (value, key) {\n        map.set(key, mapper.call(context, value, key, this$1$1));\n      });\n    });\n  };\n\n  // @pragma Mutability\n\n  Map.prototype.__iterator = function __iterator (type, reverse) {\n    return new MapIterator(this, type, reverse);\n  };\n\n  Map.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    var iterations = 0;\n    this._root &&\n      this._root.iterate(function (entry) {\n        iterations++;\n        return fn(entry[1], entry[0], this$1$1);\n      }, reverse);\n    return iterations;\n  };\n\n  Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyMap();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeMap(this.size, this._root, ownerID, this.__hash);\n  };\n\n  return Map;\n}(KeyedCollection));\n\nMap.isMap = isMap;\n\nvar MapPrototype = Map.prototype;\nMapPrototype[IS_MAP_SYMBOL] = true;\nMapPrototype[DELETE] = MapPrototype.remove;\nMapPrototype.removeAll = MapPrototype.deleteAll;\nMapPrototype.setIn = setIn;\nMapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;\nMapPrototype.update = update;\nMapPrototype.updateIn = updateIn;\nMapPrototype.merge = MapPrototype.concat = merge$1;\nMapPrototype.mergeWith = mergeWith$1;\nMapPrototype.mergeDeep = mergeDeep;\nMapPrototype.mergeDeepWith = mergeDeepWith;\nMapPrototype.mergeIn = mergeIn;\nMapPrototype.mergeDeepIn = mergeDeepIn;\nMapPrototype.withMutations = withMutations;\nMapPrototype.wasAltered = wasAltered;\nMapPrototype.asImmutable = asImmutable;\nMapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;\nMapPrototype['@@transducer/step'] = function (result, arr) {\n  return result.set(arr[0], arr[1]);\n};\nMapPrototype['@@transducer/result'] = function (obj) {\n  return obj.asImmutable();\n};\n\n// #pragma Trie Nodes\n\nvar ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n  this.ownerID = ownerID;\n  this.entries = entries;\n};\n\nArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\n\nArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n\n  if (removed && entries.length === 1) {\n    return; // undefined\n  }\n\n  if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n    return createNodes(ownerID, entries, key, value);\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n\n  if (exists) {\n    if (removed) {\n      idx === len - 1\n        ? newEntries.pop()\n        : (newEntries[idx] = newEntries.pop());\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n\n  return new ArrayMapNode(ownerID, newEntries);\n};\n\nvar BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n  this.ownerID = ownerID;\n  this.bitmap = bitmap;\n  this.nodes = nodes;\n};\n\nBitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n  var bitmap = this.bitmap;\n  return (bitmap & bit) === 0\n    ? notSetValue\n    : this.nodes[popCount(bitmap & (bit - 1))].get(\n        shift + SHIFT,\n        keyHash,\n        key,\n        notSetValue\n      );\n};\n\nBitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var bit = 1 << keyHashFrag;\n  var bitmap = this.bitmap;\n  var exists = (bitmap & bit) !== 0;\n\n  if (!exists && value === NOT_SET) {\n    return this;\n  }\n\n  var idx = popCount(bitmap & (bit - 1));\n  var nodes = this.nodes;\n  var node = exists ? nodes[idx] : undefined;\n  var newNode = updateNode(\n    node,\n    ownerID,\n    shift + SHIFT,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n\n  if (newNode === node) {\n    return this;\n  }\n\n  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n  }\n\n  if (\n    exists &&\n    !newNode &&\n    nodes.length === 2 &&\n    isLeafNode(nodes[idx ^ 1])\n  ) {\n    return nodes[idx ^ 1];\n  }\n\n  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n    return newNode;\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit;\n  var newNodes = exists\n    ? newNode\n      ? setAt(nodes, idx, newNode, isEditable)\n      : spliceOut(nodes, idx, isEditable)\n    : spliceIn(nodes, idx, newNode, isEditable);\n\n  if (isEditable) {\n    this.bitmap = newBitmap;\n    this.nodes = newNodes;\n    return this;\n  }\n\n  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n};\n\nvar HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n  this.ownerID = ownerID;\n  this.count = count;\n  this.nodes = nodes;\n};\n\nHashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var node = this.nodes[idx];\n  return node\n    ? node.get(shift + SHIFT, keyHash, key, notSetValue)\n    : notSetValue;\n};\n\nHashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var removed = value === NOT_SET;\n  var nodes = this.nodes;\n  var node = nodes[idx];\n\n  if (removed && !node) {\n    return this;\n  }\n\n  var newNode = updateNode(\n    node,\n    ownerID,\n    shift + SHIFT,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n  if (newNode === node) {\n    return this;\n  }\n\n  var newCount = this.count;\n  if (!node) {\n    newCount++;\n  } else if (!newNode) {\n    newCount--;\n    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n      return packNodes(ownerID, nodes, newCount, idx);\n    }\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newNodes = setAt(nodes, idx, newNode, isEditable);\n\n  if (isEditable) {\n    this.count = newCount;\n    this.nodes = newNodes;\n    return this;\n  }\n\n  return new HashArrayMapNode(ownerID, newCount, newNodes);\n};\n\nvar HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entries = entries;\n};\n\nHashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\n\nHashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n\n  var removed = value === NOT_SET;\n\n  if (keyHash !== this.keyHash) {\n    if (removed) {\n      return this;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n  }\n\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n\n  if (removed && len === 2) {\n    return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n\n  if (exists) {\n    if (removed) {\n      idx === len - 1\n        ? newEntries.pop()\n        : (newEntries[idx] = newEntries.pop());\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n\n  return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n};\n\nvar ValueNode = function ValueNode(ownerID, keyHash, entry) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entry = entry;\n};\n\nValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n};\n\nValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n  var keyMatch = is(key, this.entry[0]);\n  if (keyMatch ? value === this.entry[1] : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n\n  if (removed) {\n    SetRef(didChangeSize);\n    return; // undefined\n  }\n\n  if (keyMatch) {\n    if (ownerID && ownerID === this.ownerID) {\n      this.entry[1] = value;\n      return this;\n    }\n    return new ValueNode(ownerID, this.keyHash, [key, value]);\n  }\n\n  SetRef(didChangeSize);\n  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n};\n\n// #pragma Iterators\n\nArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate =\n  function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  };\n\nBitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate =\n  function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  };\n\n// eslint-disable-next-line no-unused-vars\nValueNode.prototype.iterate = function (fn, reverse) {\n  return fn(this.entry);\n};\n\nvar MapIterator = /*@__PURE__*/(function (Iterator) {\n  function MapIterator(map, type, reverse) {\n    this._type = type;\n    this._reverse = reverse;\n    this._stack = map._root && mapIteratorFrame(map._root);\n  }\n\n  if ( Iterator ) MapIterator.__proto__ = Iterator;\n  MapIterator.prototype = Object.create( Iterator && Iterator.prototype );\n  MapIterator.prototype.constructor = MapIterator;\n\n  MapIterator.prototype.next = function next () {\n    var type = this._type;\n    var stack = this._stack;\n    while (stack) {\n      var node = stack.node;\n      var index = stack.index++;\n      var maxIndex = (void 0);\n      if (node.entry) {\n        if (index === 0) {\n          return mapIteratorValue(type, node.entry);\n        }\n      } else if (node.entries) {\n        maxIndex = node.entries.length - 1;\n        if (index <= maxIndex) {\n          return mapIteratorValue(\n            type,\n            node.entries[this._reverse ? maxIndex - index : index]\n          );\n        }\n      } else {\n        maxIndex = node.nodes.length - 1;\n        if (index <= maxIndex) {\n          var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n          if (subNode) {\n            if (subNode.entry) {\n              return mapIteratorValue(type, subNode.entry);\n            }\n            stack = this._stack = mapIteratorFrame(subNode, stack);\n          }\n          continue;\n        }\n      }\n      stack = this._stack = this._stack.__prev;\n    }\n    return iteratorDone();\n  };\n\n  return MapIterator;\n}(Iterator));\n\nfunction mapIteratorValue(type, entry) {\n  return iteratorValue(type, entry[0], entry[1]);\n}\n\nfunction mapIteratorFrame(node, prev) {\n  return {\n    node: node,\n    index: 0,\n    __prev: prev,\n  };\n}\n\nfunction makeMap(size, root, ownerID, hash) {\n  var map = Object.create(MapPrototype);\n  map.size = size;\n  map._root = root;\n  map.__ownerID = ownerID;\n  map.__hash = hash;\n  map.__altered = false;\n  return map;\n}\n\nvar EMPTY_MAP;\nfunction emptyMap() {\n  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n}\n\nfunction updateMap(map, k, v) {\n  var newRoot;\n  var newSize;\n  if (!map._root) {\n    if (v === NOT_SET) {\n      return map;\n    }\n    newSize = 1;\n    newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n  } else {\n    var didChangeSize = MakeRef();\n    var didAlter = MakeRef();\n    newRoot = updateNode(\n      map._root,\n      map.__ownerID,\n      0,\n      undefined,\n      k,\n      v,\n      didChangeSize,\n      didAlter\n    );\n    if (!didAlter.value) {\n      return map;\n    }\n    newSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);\n  }\n  if (map.__ownerID) {\n    map.size = newSize;\n    map._root = newRoot;\n    map.__hash = undefined;\n    map.__altered = true;\n    return map;\n  }\n  return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n}\n\nfunction updateNode(\n  node,\n  ownerID,\n  shift,\n  keyHash,\n  key,\n  value,\n  didChangeSize,\n  didAlter\n) {\n  if (!node) {\n    if (value === NOT_SET) {\n      return node;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return new ValueNode(ownerID, keyHash, [key, value]);\n  }\n  return node.update(\n    ownerID,\n    shift,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n}\n\nfunction isLeafNode(node) {\n  return (\n    node.constructor === ValueNode || node.constructor === HashCollisionNode\n  );\n}\n\nfunction mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n  if (node.keyHash === keyHash) {\n    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n  }\n\n  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n  var newNode;\n  var nodes =\n    idx1 === idx2\n      ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]\n      : ((newNode = new ValueNode(ownerID, keyHash, entry)),\n        idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n  return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n}\n\nfunction createNodes(ownerID, entries, key, value) {\n  if (!ownerID) {\n    ownerID = new OwnerID();\n  }\n  var node = new ValueNode(ownerID, hash(key), [key, value]);\n  for (var ii = 0; ii < entries.length; ii++) {\n    var entry = entries[ii];\n    node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n  }\n  return node;\n}\n\nfunction packNodes(ownerID, nodes, count, excluding) {\n  var bitmap = 0;\n  var packedII = 0;\n  var packedNodes = new Array(count);\n  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n    var node = nodes[ii];\n    if (node !== undefined && ii !== excluding) {\n      bitmap |= bit;\n      packedNodes[packedII++] = node;\n    }\n  }\n  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n}\n\nfunction expandNodes(ownerID, nodes, bitmap, including, node) {\n  var count = 0;\n  var expandedNodes = new Array(SIZE);\n  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n  }\n  expandedNodes[including] = node;\n  return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n}\n\nfunction popCount(x) {\n  x -= (x >> 1) & 0x55555555;\n  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n  x = (x + (x >> 4)) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n\nfunction setAt(array, idx, val, canEdit) {\n  var newArray = canEdit ? array : arrCopy(array);\n  newArray[idx] = val;\n  return newArray;\n}\n\nfunction spliceIn(array, idx, val, canEdit) {\n  var newLen = array.length + 1;\n  if (canEdit && idx + 1 === newLen) {\n    array[idx] = val;\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      newArray[ii] = val;\n      after = -1;\n    } else {\n      newArray[ii] = array[ii + after];\n    }\n  }\n  return newArray;\n}\n\nfunction spliceOut(array, idx, canEdit) {\n  var newLen = array.length - 1;\n  if (canEdit && idx === newLen) {\n    array.pop();\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      after = 1;\n    }\n    newArray[ii] = array[ii + after];\n  }\n  return newArray;\n}\n\nvar MAX_ARRAY_MAP_SIZE = SIZE / 4;\nvar MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\nvar MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\nvar IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';\n\nfunction isList(maybeList) {\n  return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);\n}\n\nvar List = /*@__PURE__*/(function (IndexedCollection) {\n  function List(value) {\n    var empty = emptyList();\n    if (value === null || value === undefined) {\n      return empty;\n    }\n    if (isList(value)) {\n      return value;\n    }\n    var iter = IndexedCollection(value);\n    var size = iter.size;\n    if (size === 0) {\n      return empty;\n    }\n    assertNotInfinite(size);\n    if (size > 0 && size < SIZE) {\n      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n    }\n    return empty.withMutations(function (list) {\n      list.setSize(size);\n      iter.forEach(function (v, i) { return list.set(i, v); });\n    });\n  }\n\n  if ( IndexedCollection ) List.__proto__ = IndexedCollection;\n  List.prototype = Object.create( IndexedCollection && IndexedCollection.prototype );\n  List.prototype.constructor = List;\n\n  List.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  List.prototype.toString = function toString () {\n    return this.__toString('List [', ']');\n  };\n\n  // @pragma Access\n\n  List.prototype.get = function get (index, notSetValue) {\n    index = wrapIndex(this, index);\n    if (index >= 0 && index < this.size) {\n      index += this._origin;\n      var node = listNodeFor(this, index);\n      return node && node.array[index & MASK];\n    }\n    return notSetValue;\n  };\n\n  // @pragma Modification\n\n  List.prototype.set = function set (index, value) {\n    return updateList(this, index, value);\n  };\n\n  List.prototype.remove = function remove (index) {\n    return !this.has(index)\n      ? this\n      : index === 0\n      ? this.shift()\n      : index === this.size - 1\n      ? this.pop()\n      : this.splice(index, 1);\n  };\n\n  List.prototype.insert = function insert (index, value) {\n    return this.splice(index, 0, value);\n  };\n\n  List.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = this._origin = this._capacity = 0;\n      this._level = SHIFT;\n      this._root = this._tail = this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyList();\n  };\n\n  List.prototype.push = function push (/*...values*/) {\n    var values = arguments;\n    var oldSize = this.size;\n    return this.withMutations(function (list) {\n      setListBounds(list, 0, oldSize + values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(oldSize + ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.pop = function pop () {\n    return setListBounds(this, 0, -1);\n  };\n\n  List.prototype.unshift = function unshift (/*...values*/) {\n    var values = arguments;\n    return this.withMutations(function (list) {\n      setListBounds(list, -values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.shift = function shift () {\n    return setListBounds(this, 1);\n  };\n\n  // @pragma Composition\n\n  List.prototype.concat = function concat (/*...collections*/) {\n    var arguments$1 = arguments;\n\n    var seqs = [];\n    for (var i = 0; i < arguments.length; i++) {\n      var argument = arguments$1[i];\n      var seq = IndexedCollection(\n        typeof argument !== 'string' && hasIterator(argument)\n          ? argument\n          : [argument]\n      );\n      if (seq.size !== 0) {\n        seqs.push(seq);\n      }\n    }\n    if (seqs.length === 0) {\n      return this;\n    }\n    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {\n      return this.constructor(seqs[0]);\n    }\n    return this.withMutations(function (list) {\n      seqs.forEach(function (seq) { return seq.forEach(function (value) { return list.push(value); }); });\n    });\n  };\n\n  List.prototype.setSize = function setSize (size) {\n    return setListBounds(this, 0, size);\n  };\n\n  List.prototype.map = function map (mapper, context) {\n    var this$1$1 = this;\n\n    return this.withMutations(function (list) {\n      for (var i = 0; i < this$1$1.size; i++) {\n        list.set(i, mapper.call(context, list.get(i), i, this$1$1));\n      }\n    });\n  };\n\n  // @pragma Iteration\n\n  List.prototype.slice = function slice (begin, end) {\n    var size = this.size;\n    if (wholeSlice(begin, end, size)) {\n      return this;\n    }\n    return setListBounds(\n      this,\n      resolveBegin(begin, size),\n      resolveEnd(end, size)\n    );\n  };\n\n  List.prototype.__iterator = function __iterator (type, reverse) {\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    return new Iterator(function () {\n      var value = values();\n      return value === DONE\n        ? iteratorDone()\n        : iteratorValue(type, reverse ? --index : index++, value);\n    });\n  };\n\n  List.prototype.__iterate = function __iterate (fn, reverse) {\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    var value;\n    while ((value = values()) !== DONE) {\n      if (fn(value, reverse ? --index : index++, this) === false) {\n        break;\n      }\n    }\n    return index;\n  };\n\n  List.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyList();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeList(\n      this._origin,\n      this._capacity,\n      this._level,\n      this._root,\n      this._tail,\n      ownerID,\n      this.__hash\n    );\n  };\n\n  return List;\n}(IndexedCollection));\n\nList.isList = isList;\n\nvar ListPrototype = List.prototype;\nListPrototype[IS_LIST_SYMBOL] = true;\nListPrototype[DELETE] = ListPrototype.remove;\nListPrototype.merge = ListPrototype.concat;\nListPrototype.setIn = setIn;\nListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;\nListPrototype.update = update;\nListPrototype.updateIn = updateIn;\nListPrototype.mergeIn = mergeIn;\nListPrototype.mergeDeepIn = mergeDeepIn;\nListPrototype.withMutations = withMutations;\nListPrototype.wasAltered = wasAltered;\nListPrototype.asImmutable = asImmutable;\nListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;\nListPrototype['@@transducer/step'] = function (result, arr) {\n  return result.push(arr);\n};\nListPrototype['@@transducer/result'] = function (obj) {\n  return obj.asImmutable();\n};\n\nvar VNode = function VNode(array, ownerID) {\n  this.array = array;\n  this.ownerID = ownerID;\n};\n\n// TODO: seems like these methods are very similar\n\nVNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {\n  if (index === level ? 1 << level : this.array.length === 0) {\n    return this;\n  }\n  var originIndex = (index >>> level) & MASK;\n  if (originIndex >= this.array.length) {\n    return new VNode([], ownerID);\n  }\n  var removingFirst = originIndex === 0;\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[originIndex];\n    newChild =\n      oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && removingFirst) {\n      return this;\n    }\n  }\n  if (removingFirst && !newChild) {\n    return this;\n  }\n  var editable = editableVNode(this, ownerID);\n  if (!removingFirst) {\n    for (var ii = 0; ii < originIndex; ii++) {\n      editable.array[ii] = undefined;\n    }\n  }\n  if (newChild) {\n    editable.array[originIndex] = newChild;\n  }\n  return editable;\n};\n\nVNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {\n  if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n    return this;\n  }\n  var sizeIndex = ((index - 1) >>> level) & MASK;\n  if (sizeIndex >= this.array.length) {\n    return this;\n  }\n\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[sizeIndex];\n    newChild =\n      oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n      return this;\n    }\n  }\n\n  var editable = editableVNode(this, ownerID);\n  editable.array.splice(sizeIndex + 1);\n  if (newChild) {\n    editable.array[sizeIndex] = newChild;\n  }\n  return editable;\n};\n\nvar DONE = {};\n\nfunction iterateList(list, reverse) {\n  var left = list._origin;\n  var right = list._capacity;\n  var tailPos = getTailOffset(right);\n  var tail = list._tail;\n\n  return iterateNodeOrLeaf(list._root, list._level, 0);\n\n  function iterateNodeOrLeaf(node, level, offset) {\n    return level === 0\n      ? iterateLeaf(node, offset)\n      : iterateNode(node, level, offset);\n  }\n\n  function iterateLeaf(node, offset) {\n    var array = offset === tailPos ? tail && tail.array : node && node.array;\n    var from = offset > left ? 0 : left - offset;\n    var to = right - offset;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      if (from === to) {\n        return DONE;\n      }\n      var idx = reverse ? --to : from++;\n      return array && array[idx];\n    };\n  }\n\n  function iterateNode(node, level, offset) {\n    var values;\n    var array = node && node.array;\n    var from = offset > left ? 0 : (left - offset) >> level;\n    var to = ((right - offset) >> level) + 1;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      while (true) {\n        if (values) {\n          var value = values();\n          if (value !== DONE) {\n            return value;\n          }\n          values = null;\n        }\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        values = iterateNodeOrLeaf(\n          array && array[idx],\n          level - SHIFT,\n          offset + (idx << level)\n        );\n      }\n    };\n  }\n}\n\nfunction makeList(origin, capacity, level, root, tail, ownerID, hash) {\n  var list = Object.create(ListPrototype);\n  list.size = capacity - origin;\n  list._origin = origin;\n  list._capacity = capacity;\n  list._level = level;\n  list._root = root;\n  list._tail = tail;\n  list.__ownerID = ownerID;\n  list.__hash = hash;\n  list.__altered = false;\n  return list;\n}\n\nvar EMPTY_LIST;\nfunction emptyList() {\n  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n}\n\nfunction updateList(list, index, value) {\n  index = wrapIndex(list, index);\n\n  if (index !== index) {\n    return list;\n  }\n\n  if (index >= list.size || index < 0) {\n    return list.withMutations(function (list) {\n      index < 0\n        ? setListBounds(list, index).set(0, value)\n        : setListBounds(list, 0, index + 1).set(index, value);\n    });\n  }\n\n  index += list._origin;\n\n  var newTail = list._tail;\n  var newRoot = list._root;\n  var didAlter = MakeRef();\n  if (index >= getTailOffset(list._capacity)) {\n    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n  } else {\n    newRoot = updateVNode(\n      newRoot,\n      list.__ownerID,\n      list._level,\n      index,\n      value,\n      didAlter\n    );\n  }\n\n  if (!didAlter.value) {\n    return list;\n  }\n\n  if (list.__ownerID) {\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n}\n\nfunction updateVNode(node, ownerID, level, index, value, didAlter) {\n  var idx = (index >>> level) & MASK;\n  var nodeHas = node && idx < node.array.length;\n  if (!nodeHas && value === undefined) {\n    return node;\n  }\n\n  var newNode;\n\n  if (level > 0) {\n    var lowerNode = node && node.array[idx];\n    var newLowerNode = updateVNode(\n      lowerNode,\n      ownerID,\n      level - SHIFT,\n      index,\n      value,\n      didAlter\n    );\n    if (newLowerNode === lowerNode) {\n      return node;\n    }\n    newNode = editableVNode(node, ownerID);\n    newNode.array[idx] = newLowerNode;\n    return newNode;\n  }\n\n  if (nodeHas && node.array[idx] === value) {\n    return node;\n  }\n\n  if (didAlter) {\n    SetRef(didAlter);\n  }\n\n  newNode = editableVNode(node, ownerID);\n  if (value === undefined && idx === newNode.array.length - 1) {\n    newNode.array.pop();\n  } else {\n    newNode.array[idx] = value;\n  }\n  return newNode;\n}\n\nfunction editableVNode(node, ownerID) {\n  if (ownerID && node && ownerID === node.ownerID) {\n    return node;\n  }\n  return new VNode(node ? node.array.slice() : [], ownerID);\n}\n\nfunction listNodeFor(list, rawIndex) {\n  if (rawIndex >= getTailOffset(list._capacity)) {\n    return list._tail;\n  }\n  if (rawIndex < 1 << (list._level + SHIFT)) {\n    var node = list._root;\n    var level = list._level;\n    while (node && level > 0) {\n      node = node.array[(rawIndex >>> level) & MASK];\n      level -= SHIFT;\n    }\n    return node;\n  }\n}\n\nfunction setListBounds(list, begin, end) {\n  // Sanitize begin & end using this shorthand for ToInt32(argument)\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n  if (begin !== undefined) {\n    begin |= 0;\n  }\n  if (end !== undefined) {\n    end |= 0;\n  }\n  var owner = list.__ownerID || new OwnerID();\n  var oldOrigin = list._origin;\n  var oldCapacity = list._capacity;\n  var newOrigin = oldOrigin + begin;\n  var newCapacity =\n    end === undefined\n      ? oldCapacity\n      : end < 0\n      ? oldCapacity + end\n      : oldOrigin + end;\n  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n    return list;\n  }\n\n  // If it's going to end after it starts, it's empty.\n  if (newOrigin >= newCapacity) {\n    return list.clear();\n  }\n\n  var newLevel = list._level;\n  var newRoot = list._root;\n\n  // New origin might need creating a higher root.\n  var offsetShift = 0;\n  while (newOrigin + offsetShift < 0) {\n    newRoot = new VNode(\n      newRoot && newRoot.array.length ? [undefined, newRoot] : [],\n      owner\n    );\n    newLevel += SHIFT;\n    offsetShift += 1 << newLevel;\n  }\n  if (offsetShift) {\n    newOrigin += offsetShift;\n    oldOrigin += offsetShift;\n    newCapacity += offsetShift;\n    oldCapacity += offsetShift;\n  }\n\n  var oldTailOffset = getTailOffset(oldCapacity);\n  var newTailOffset = getTailOffset(newCapacity);\n\n  // New size might need creating a higher root.\n  while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n    newRoot = new VNode(\n      newRoot && newRoot.array.length ? [newRoot] : [],\n      owner\n    );\n    newLevel += SHIFT;\n  }\n\n  // Locate or create the new tail.\n  var oldTail = list._tail;\n  var newTail =\n    newTailOffset < oldTailOffset\n      ? listNodeFor(list, newCapacity - 1)\n      : newTailOffset > oldTailOffset\n      ? new VNode([], owner)\n      : oldTail;\n\n  // Merge Tail into tree.\n  if (\n    oldTail &&\n    newTailOffset > oldTailOffset &&\n    newOrigin < oldCapacity &&\n    oldTail.array.length\n  ) {\n    newRoot = editableVNode(newRoot, owner);\n    var node = newRoot;\n    for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n      var idx = (oldTailOffset >>> level) & MASK;\n      node = node.array[idx] = editableVNode(node.array[idx], owner);\n    }\n    node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n  }\n\n  // If the size has been reduced, there's a chance the tail needs to be trimmed.\n  if (newCapacity < oldCapacity) {\n    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n  }\n\n  // If the new origin is within the tail, then we do not need a root.\n  if (newOrigin >= newTailOffset) {\n    newOrigin -= newTailOffset;\n    newCapacity -= newTailOffset;\n    newLevel = SHIFT;\n    newRoot = null;\n    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n    offsetShift = 0;\n\n    // Identify the new top root node of the subtree of the old root.\n    while (newRoot) {\n      var beginIndex = (newOrigin >>> newLevel) & MASK;\n      if ((beginIndex !== newTailOffset >>> newLevel) & MASK) {\n        break;\n      }\n      if (beginIndex) {\n        offsetShift += (1 << newLevel) * beginIndex;\n      }\n      newLevel -= SHIFT;\n      newRoot = newRoot.array[beginIndex];\n    }\n\n    // Trim the new sides of the new root.\n    if (newRoot && newOrigin > oldOrigin) {\n      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n    }\n    if (newRoot && newTailOffset < oldTailOffset) {\n      newRoot = newRoot.removeAfter(\n        owner,\n        newLevel,\n        newTailOffset - offsetShift\n      );\n    }\n    if (offsetShift) {\n      newOrigin -= offsetShift;\n      newCapacity -= offsetShift;\n    }\n  }\n\n  if (list.__ownerID) {\n    list.size = newCapacity - newOrigin;\n    list._origin = newOrigin;\n    list._capacity = newCapacity;\n    list._level = newLevel;\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n}\n\nfunction getTailOffset(size) {\n  return size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;\n}\n\nvar OrderedMap = /*@__PURE__*/(function (Map) {\n  function OrderedMap(value) {\n    return value === null || value === undefined\n      ? emptyOrderedMap()\n      : isOrderedMap(value)\n      ? value\n      : emptyOrderedMap().withMutations(function (map) {\n          var iter = KeyedCollection(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function (v, k) { return map.set(k, v); });\n        });\n  }\n\n  if ( Map ) OrderedMap.__proto__ = Map;\n  OrderedMap.prototype = Object.create( Map && Map.prototype );\n  OrderedMap.prototype.constructor = OrderedMap;\n\n  OrderedMap.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  OrderedMap.prototype.toString = function toString () {\n    return this.__toString('OrderedMap {', '}');\n  };\n\n  // @pragma Access\n\n  OrderedMap.prototype.get = function get (k, notSetValue) {\n    var index = this._map.get(k);\n    return index !== undefined ? this._list.get(index)[1] : notSetValue;\n  };\n\n  // @pragma Modification\n\n  OrderedMap.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._map.clear();\n      this._list.clear();\n      this.__altered = true;\n      return this;\n    }\n    return emptyOrderedMap();\n  };\n\n  OrderedMap.prototype.set = function set (k, v) {\n    return updateOrderedMap(this, k, v);\n  };\n\n  OrderedMap.prototype.remove = function remove (k) {\n    return updateOrderedMap(this, k, NOT_SET);\n  };\n\n  OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    return this._list.__iterate(\n      function (entry) { return entry && fn(entry[1], entry[0], this$1$1); },\n      reverse\n    );\n  };\n\n  OrderedMap.prototype.__iterator = function __iterator (type, reverse) {\n    return this._list.fromEntrySeq().__iterator(type, reverse);\n  };\n\n  OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map.__ensureOwner(ownerID);\n    var newList = this._list.__ensureOwner(ownerID);\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyOrderedMap();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      this._map = newMap;\n      this._list = newList;\n      return this;\n    }\n    return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n  };\n\n  return OrderedMap;\n}(Map));\n\nOrderedMap.isOrderedMap = isOrderedMap;\n\nOrderedMap.prototype[IS_ORDERED_SYMBOL] = true;\nOrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\nfunction makeOrderedMap(map, list, ownerID, hash) {\n  var omap = Object.create(OrderedMap.prototype);\n  omap.size = map ? map.size : 0;\n  omap._map = map;\n  omap._list = list;\n  omap.__ownerID = ownerID;\n  omap.__hash = hash;\n  omap.__altered = false;\n  return omap;\n}\n\nvar EMPTY_ORDERED_MAP;\nfunction emptyOrderedMap() {\n  return (\n    EMPTY_ORDERED_MAP ||\n    (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()))\n  );\n}\n\nfunction updateOrderedMap(omap, k, v) {\n  var map = omap._map;\n  var list = omap._list;\n  var i = map.get(k);\n  var has = i !== undefined;\n  var newMap;\n  var newList;\n  if (v === NOT_SET) {\n    // removed\n    if (!has) {\n      return omap;\n    }\n    if (list.size >= SIZE && list.size >= map.size * 2) {\n      newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });\n      newMap = newList\n        .toKeyedSeq()\n        .map(function (entry) { return entry[0]; })\n        .flip()\n        .toMap();\n      if (omap.__ownerID) {\n        newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n      }\n    } else {\n      newMap = map.remove(k);\n      newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n    }\n  } else if (has) {\n    if (v === list.get(i)[1]) {\n      return omap;\n    }\n    newMap = map;\n    newList = list.set(i, [k, v]);\n  } else {\n    newMap = map.set(k, list.size);\n    newList = list.set(list.size, [k, v]);\n  }\n  if (omap.__ownerID) {\n    omap.size = newMap.size;\n    omap._map = newMap;\n    omap._list = newList;\n    omap.__hash = undefined;\n    omap.__altered = true;\n    return omap;\n  }\n  return makeOrderedMap(newMap, newList);\n}\n\nvar IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';\n\nfunction isStack(maybeStack) {\n  return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);\n}\n\nvar Stack = /*@__PURE__*/(function (IndexedCollection) {\n  function Stack(value) {\n    return value === null || value === undefined\n      ? emptyStack()\n      : isStack(value)\n      ? value\n      : emptyStack().pushAll(value);\n  }\n\n  if ( IndexedCollection ) Stack.__proto__ = IndexedCollection;\n  Stack.prototype = Object.create( IndexedCollection && IndexedCollection.prototype );\n  Stack.prototype.constructor = Stack;\n\n  Stack.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  Stack.prototype.toString = function toString () {\n    return this.__toString('Stack [', ']');\n  };\n\n  // @pragma Access\n\n  Stack.prototype.get = function get (index, notSetValue) {\n    var head = this._head;\n    index = wrapIndex(this, index);\n    while (head && index--) {\n      head = head.next;\n    }\n    return head ? head.value : notSetValue;\n  };\n\n  Stack.prototype.peek = function peek () {\n    return this._head && this._head.value;\n  };\n\n  // @pragma Modification\n\n  Stack.prototype.push = function push (/*...values*/) {\n    var arguments$1 = arguments;\n\n    if (arguments.length === 0) {\n      return this;\n    }\n    var newSize = this.size + arguments.length;\n    var head = this._head;\n    for (var ii = arguments.length - 1; ii >= 0; ii--) {\n      head = {\n        value: arguments$1[ii],\n        next: head,\n      };\n    }\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  Stack.prototype.pushAll = function pushAll (iter) {\n    iter = IndexedCollection(iter);\n    if (iter.size === 0) {\n      return this;\n    }\n    if (this.size === 0 && isStack(iter)) {\n      return iter;\n    }\n    assertNotInfinite(iter.size);\n    var newSize = this.size;\n    var head = this._head;\n    iter.__iterate(function (value) {\n      newSize++;\n      head = {\n        value: value,\n        next: head,\n      };\n    }, /* reverse */ true);\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  Stack.prototype.pop = function pop () {\n    return this.slice(1);\n  };\n\n  Stack.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._head = undefined;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyStack();\n  };\n\n  Stack.prototype.slice = function slice (begin, end) {\n    if (wholeSlice(begin, end, this.size)) {\n      return this;\n    }\n    var resolvedBegin = resolveBegin(begin, this.size);\n    var resolvedEnd = resolveEnd(end, this.size);\n    if (resolvedEnd !== this.size) {\n      // super.slice(begin, end);\n      return IndexedCollection.prototype.slice.call(this, begin, end);\n    }\n    var newSize = this.size - resolvedBegin;\n    var head = this._head;\n    while (resolvedBegin--) {\n      head = head.next;\n    }\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  // @pragma Mutability\n\n  Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyStack();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeStack(this.size, this._head, ownerID, this.__hash);\n  };\n\n  // @pragma Iteration\n\n  Stack.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    if (reverse) {\n      return new ArraySeq(this.toArray()).__iterate(\n        function (v, k) { return fn(v, k, this$1$1); },\n        reverse\n      );\n    }\n    var iterations = 0;\n    var node = this._head;\n    while (node) {\n      if (fn(node.value, iterations++, this) === false) {\n        break;\n      }\n      node = node.next;\n    }\n    return iterations;\n  };\n\n  Stack.prototype.__iterator = function __iterator (type, reverse) {\n    if (reverse) {\n      return new ArraySeq(this.toArray()).__iterator(type, reverse);\n    }\n    var iterations = 0;\n    var node = this._head;\n    return new Iterator(function () {\n      if (node) {\n        var value = node.value;\n        node = node.next;\n        return iteratorValue(type, iterations++, value);\n      }\n      return iteratorDone();\n    });\n  };\n\n  return Stack;\n}(IndexedCollection));\n\nStack.isStack = isStack;\n\nvar StackPrototype = Stack.prototype;\nStackPrototype[IS_STACK_SYMBOL] = true;\nStackPrototype.shift = StackPrototype.pop;\nStackPrototype.unshift = StackPrototype.push;\nStackPrototype.unshiftAll = StackPrototype.pushAll;\nStackPrototype.withMutations = withMutations;\nStackPrototype.wasAltered = wasAltered;\nStackPrototype.asImmutable = asImmutable;\nStackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;\nStackPrototype['@@transducer/step'] = function (result, arr) {\n  return result.unshift(arr);\n};\nStackPrototype['@@transducer/result'] = function (obj) {\n  return obj.asImmutable();\n};\n\nfunction makeStack(size, head, ownerID, hash) {\n  var map = Object.create(StackPrototype);\n  map.size = size;\n  map._head = head;\n  map.__ownerID = ownerID;\n  map.__hash = hash;\n  map.__altered = false;\n  return map;\n}\n\nvar EMPTY_STACK;\nfunction emptyStack() {\n  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n}\n\nvar IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';\n\nfunction isSet(maybeSet) {\n  return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);\n}\n\nfunction isOrderedSet(maybeOrderedSet) {\n  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n}\n\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (\n    !isCollection(b) ||\n    (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||\n    (a.__hash !== undefined &&\n      b.__hash !== undefined &&\n      a.__hash !== b.__hash) ||\n    isKeyed(a) !== isKeyed(b) ||\n    isIndexed(a) !== isIndexed(b) ||\n    isOrdered(a) !== isOrdered(b)\n  ) {\n    return false;\n  }\n\n  if (a.size === 0 && b.size === 0) {\n    return true;\n  }\n\n  var notAssociative = !isAssociative(a);\n\n  if (isOrdered(a)) {\n    var entries = a.entries();\n    return (\n      b.every(function (v, k) {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done\n    );\n  }\n\n  var flipped = false;\n\n  if (a.size === undefined) {\n    if (b.size === undefined) {\n      if (typeof a.cacheResult === 'function') {\n        a.cacheResult();\n      }\n    } else {\n      flipped = true;\n      var _ = a;\n      a = b;\n      b = _;\n    }\n  }\n\n  var allEqual = true;\n  var bSize = b.__iterate(function (v, k) {\n    if (\n      notAssociative\n        ? !a.has(v)\n        : flipped\n        ? !is(v, a.get(k, NOT_SET))\n        : !is(a.get(k, NOT_SET), v)\n    ) {\n      allEqual = false;\n      return false;\n    }\n  });\n\n  return allEqual && a.size === bSize;\n}\n\nfunction mixin(ctor, methods) {\n  var keyCopier = function (key) {\n    ctor.prototype[key] = methods[key];\n  };\n  Object.keys(methods).forEach(keyCopier);\n  Object.getOwnPropertySymbols &&\n    Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n  return ctor;\n}\n\nfunction toJS(value) {\n  if (!value || typeof value !== 'object') {\n    return value;\n  }\n  if (!isCollection(value)) {\n    if (!isDataStructure(value)) {\n      return value;\n    }\n    value = Seq(value);\n  }\n  if (isKeyed(value)) {\n    var result$1 = {};\n    value.__iterate(function (v, k) {\n      result$1[k] = toJS(v);\n    });\n    return result$1;\n  }\n  var result = [];\n  value.__iterate(function (v) {\n    result.push(toJS(v));\n  });\n  return result;\n}\n\nvar Set = /*@__PURE__*/(function (SetCollection) {\n  function Set(value) {\n    return value === null || value === undefined\n      ? emptySet()\n      : isSet(value) && !isOrdered(value)\n      ? value\n      : emptySet().withMutations(function (set) {\n          var iter = SetCollection(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function (v) { return set.add(v); });\n        });\n  }\n\n  if ( SetCollection ) Set.__proto__ = SetCollection;\n  Set.prototype = Object.create( SetCollection && SetCollection.prototype );\n  Set.prototype.constructor = Set;\n\n  Set.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  Set.fromKeys = function fromKeys (value) {\n    return this(KeyedCollection(value).keySeq());\n  };\n\n  Set.intersect = function intersect (sets) {\n    sets = Collection(sets).toArray();\n    return sets.length\n      ? SetPrototype.intersect.apply(Set(sets.pop()), sets)\n      : emptySet();\n  };\n\n  Set.union = function union (sets) {\n    sets = Collection(sets).toArray();\n    return sets.length\n      ? SetPrototype.union.apply(Set(sets.pop()), sets)\n      : emptySet();\n  };\n\n  Set.prototype.toString = function toString () {\n    return this.__toString('Set {', '}');\n  };\n\n  // @pragma Access\n\n  Set.prototype.has = function has (value) {\n    return this._map.has(value);\n  };\n\n  // @pragma Modification\n\n  Set.prototype.add = function add (value) {\n    return updateSet(this, this._map.set(value, value));\n  };\n\n  Set.prototype.remove = function remove (value) {\n    return updateSet(this, this._map.remove(value));\n  };\n\n  Set.prototype.clear = function clear () {\n    return updateSet(this, this._map.clear());\n  };\n\n  // @pragma Composition\n\n  Set.prototype.map = function map (mapper, context) {\n    var this$1$1 = this;\n\n    // keep track if the set is altered by the map function\n    var didChanges = false;\n\n    var newMap = updateSet(\n      this,\n      this._map.mapEntries(function (ref) {\n        var v = ref[1];\n\n        var mapped = mapper.call(context, v, v, this$1$1);\n\n        if (mapped !== v) {\n          didChanges = true;\n        }\n\n        return [mapped, mapped];\n      }, context)\n    );\n\n    return didChanges ? newMap : this;\n  };\n\n  Set.prototype.union = function union () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    iters = iters.filter(function (x) { return x.size !== 0; });\n    if (iters.length === 0) {\n      return this;\n    }\n    if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n      return this.constructor(iters[0]);\n    }\n    return this.withMutations(function (set) {\n      for (var ii = 0; ii < iters.length; ii++) {\n        SetCollection(iters[ii]).forEach(function (value) { return set.add(value); });\n      }\n    });\n  };\n\n  Set.prototype.intersect = function intersect () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    if (iters.length === 0) {\n      return this;\n    }\n    iters = iters.map(function (iter) { return SetCollection(iter); });\n    var toRemove = [];\n    this.forEach(function (value) {\n      if (!iters.every(function (iter) { return iter.includes(value); })) {\n        toRemove.push(value);\n      }\n    });\n    return this.withMutations(function (set) {\n      toRemove.forEach(function (value) {\n        set.remove(value);\n      });\n    });\n  };\n\n  Set.prototype.subtract = function subtract () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    if (iters.length === 0) {\n      return this;\n    }\n    iters = iters.map(function (iter) { return SetCollection(iter); });\n    var toRemove = [];\n    this.forEach(function (value) {\n      if (iters.some(function (iter) { return iter.includes(value); })) {\n        toRemove.push(value);\n      }\n    });\n    return this.withMutations(function (set) {\n      toRemove.forEach(function (value) {\n        set.remove(value);\n      });\n    });\n  };\n\n  Set.prototype.sort = function sort (comparator) {\n    // Late binding\n    return OrderedSet(sortFactory(this, comparator));\n  };\n\n  Set.prototype.sortBy = function sortBy (mapper, comparator) {\n    // Late binding\n    return OrderedSet(sortFactory(this, comparator, mapper));\n  };\n\n  Set.prototype.wasAltered = function wasAltered () {\n    return this._map.wasAltered();\n  };\n\n  Set.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    return this._map.__iterate(function (k) { return fn(k, k, this$1$1); }, reverse);\n  };\n\n  Set.prototype.__iterator = function __iterator (type, reverse) {\n    return this._map.__iterator(type, reverse);\n  };\n\n  Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map.__ensureOwner(ownerID);\n    if (!ownerID) {\n      if (this.size === 0) {\n        return this.__empty();\n      }\n      this.__ownerID = ownerID;\n      this._map = newMap;\n      return this;\n    }\n    return this.__make(newMap, ownerID);\n  };\n\n  return Set;\n}(SetCollection));\n\nSet.isSet = isSet;\n\nvar SetPrototype = Set.prototype;\nSetPrototype[IS_SET_SYMBOL] = true;\nSetPrototype[DELETE] = SetPrototype.remove;\nSetPrototype.merge = SetPrototype.concat = SetPrototype.union;\nSetPrototype.withMutations = withMutations;\nSetPrototype.asImmutable = asImmutable;\nSetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;\nSetPrototype['@@transducer/step'] = function (result, arr) {\n  return result.add(arr);\n};\nSetPrototype['@@transducer/result'] = function (obj) {\n  return obj.asImmutable();\n};\n\nSetPrototype.__empty = emptySet;\nSetPrototype.__make = makeSet;\n\nfunction updateSet(set, newMap) {\n  if (set.__ownerID) {\n    set.size = newMap.size;\n    set._map = newMap;\n    return set;\n  }\n  return newMap === set._map\n    ? set\n    : newMap.size === 0\n    ? set.__empty()\n    : set.__make(newMap);\n}\n\nfunction makeSet(map, ownerID) {\n  var set = Object.create(SetPrototype);\n  set.size = map ? map.size : 0;\n  set._map = map;\n  set.__ownerID = ownerID;\n  return set;\n}\n\nvar EMPTY_SET;\nfunction emptySet() {\n  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n}\n\n/**\n * Returns a lazy seq of nums from start (inclusive) to end\n * (exclusive), by step, where start defaults to 0, step to 1, and end to\n * infinity. When start is equal to end, returns empty list.\n */\nvar Range = /*@__PURE__*/(function (IndexedSeq) {\n  function Range(start, end, step) {\n    if (!(this instanceof Range)) {\n      return new Range(start, end, step);\n    }\n    invariant(step !== 0, 'Cannot step a Range by 0');\n    start = start || 0;\n    if (end === undefined) {\n      end = Infinity;\n    }\n    step = step === undefined ? 1 : Math.abs(step);\n    if (end < start) {\n      step = -step;\n    }\n    this._start = start;\n    this._end = end;\n    this._step = step;\n    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n    if (this.size === 0) {\n      if (EMPTY_RANGE) {\n        return EMPTY_RANGE;\n      }\n      EMPTY_RANGE = this;\n    }\n  }\n\n  if ( IndexedSeq ) Range.__proto__ = IndexedSeq;\n  Range.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  Range.prototype.constructor = Range;\n\n  Range.prototype.toString = function toString () {\n    if (this.size === 0) {\n      return 'Range []';\n    }\n    return (\n      'Range [ ' +\n      this._start +\n      '...' +\n      this._end +\n      (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]'\n    );\n  };\n\n  Range.prototype.get = function get (index, notSetValue) {\n    return this.has(index)\n      ? this._start + wrapIndex(this, index) * this._step\n      : notSetValue;\n  };\n\n  Range.prototype.includes = function includes (searchValue) {\n    var possibleIndex = (searchValue - this._start) / this._step;\n    return (\n      possibleIndex >= 0 &&\n      possibleIndex < this.size &&\n      possibleIndex === Math.floor(possibleIndex)\n    );\n  };\n\n  Range.prototype.slice = function slice (begin, end) {\n    if (wholeSlice(begin, end, this.size)) {\n      return this;\n    }\n    begin = resolveBegin(begin, this.size);\n    end = resolveEnd(end, this.size);\n    if (end <= begin) {\n      return new Range(0, 0);\n    }\n    return new Range(\n      this.get(begin, this._end),\n      this.get(end, this._end),\n      this._step\n    );\n  };\n\n  Range.prototype.indexOf = function indexOf (searchValue) {\n    var offsetValue = searchValue - this._start;\n    if (offsetValue % this._step === 0) {\n      var index = offsetValue / this._step;\n      if (index >= 0 && index < this.size) {\n        return index;\n      }\n    }\n    return -1;\n  };\n\n  Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n    return this.indexOf(searchValue);\n  };\n\n  Range.prototype.__iterate = function __iterate (fn, reverse) {\n    var size = this.size;\n    var step = this._step;\n    var value = reverse ? this._start + (size - 1) * step : this._start;\n    var i = 0;\n    while (i !== size) {\n      if (fn(value, reverse ? size - ++i : i++, this) === false) {\n        break;\n      }\n      value += reverse ? -step : step;\n    }\n    return i;\n  };\n\n  Range.prototype.__iterator = function __iterator (type, reverse) {\n    var size = this.size;\n    var step = this._step;\n    var value = reverse ? this._start + (size - 1) * step : this._start;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var v = value;\n      value += reverse ? -step : step;\n      return iteratorValue(type, reverse ? size - ++i : i++, v);\n    });\n  };\n\n  Range.prototype.equals = function equals (other) {\n    return other instanceof Range\n      ? this._start === other._start &&\n          this._end === other._end &&\n          this._step === other._step\n      : deepEqual(this, other);\n  };\n\n  return Range;\n}(IndexedSeq));\n\nvar EMPTY_RANGE;\n\nfunction getIn$1(collection, searchKeyPath, notSetValue) {\n  var keyPath = coerceKeyPath(searchKeyPath);\n  var i = 0;\n  while (i !== keyPath.length) {\n    collection = get(collection, keyPath[i++], NOT_SET);\n    if (collection === NOT_SET) {\n      return notSetValue;\n    }\n  }\n  return collection;\n}\n\nfunction getIn(searchKeyPath, notSetValue) {\n  return getIn$1(this, searchKeyPath, notSetValue);\n}\n\nfunction hasIn$1(collection, keyPath) {\n  return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;\n}\n\nfunction hasIn(searchKeyPath) {\n  return hasIn$1(this, searchKeyPath);\n}\n\nfunction toObject() {\n  assertNotInfinite(this.size);\n  var object = {};\n  this.__iterate(function (v, k) {\n    object[k] = v;\n  });\n  return object;\n}\n\n// Note: all of these methods are deprecated.\nCollection.isIterable = isCollection;\nCollection.isKeyed = isKeyed;\nCollection.isIndexed = isIndexed;\nCollection.isAssociative = isAssociative;\nCollection.isOrdered = isOrdered;\n\nCollection.Iterator = Iterator;\n\nmixin(Collection, {\n  // ### Conversion to other types\n\n  toArray: function toArray() {\n    assertNotInfinite(this.size);\n    var array = new Array(this.size || 0);\n    var useTuples = isKeyed(this);\n    var i = 0;\n    this.__iterate(function (v, k) {\n      // Keyed collections produce an array of tuples.\n      array[i++] = useTuples ? [k, v] : v;\n    });\n    return array;\n  },\n\n  toIndexedSeq: function toIndexedSeq() {\n    return new ToIndexedSequence(this);\n  },\n\n  toJS: function toJS$1() {\n    return toJS(this);\n  },\n\n  toKeyedSeq: function toKeyedSeq() {\n    return new ToKeyedSequence(this, true);\n  },\n\n  toMap: function toMap() {\n    // Use Late Binding here to solve the circular dependency.\n    return Map(this.toKeyedSeq());\n  },\n\n  toObject: toObject,\n\n  toOrderedMap: function toOrderedMap() {\n    // Use Late Binding here to solve the circular dependency.\n    return OrderedMap(this.toKeyedSeq());\n  },\n\n  toOrderedSet: function toOrderedSet() {\n    // Use Late Binding here to solve the circular dependency.\n    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toSet: function toSet() {\n    // Use Late Binding here to solve the circular dependency.\n    return Set(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toSetSeq: function toSetSeq() {\n    return new ToSetSequence(this);\n  },\n\n  toSeq: function toSeq() {\n    return isIndexed(this)\n      ? this.toIndexedSeq()\n      : isKeyed(this)\n      ? this.toKeyedSeq()\n      : this.toSetSeq();\n  },\n\n  toStack: function toStack() {\n    // Use Late Binding here to solve the circular dependency.\n    return Stack(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toList: function toList() {\n    // Use Late Binding here to solve the circular dependency.\n    return List(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  // ### Common JavaScript methods and properties\n\n  toString: function toString() {\n    return '[Collection]';\n  },\n\n  __toString: function __toString(head, tail) {\n    if (this.size === 0) {\n      return head + tail;\n    }\n    return (\n      head +\n      ' ' +\n      this.toSeq().map(this.__toStringMapper).join(', ') +\n      ' ' +\n      tail\n    );\n  },\n\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  concat: function concat() {\n    var values = [], len = arguments.length;\n    while ( len-- ) values[ len ] = arguments[ len ];\n\n    return reify(this, concatFactory(this, values));\n  },\n\n  includes: function includes(searchValue) {\n    return this.some(function (value) { return is(value, searchValue); });\n  },\n\n  entries: function entries() {\n    return this.__iterator(ITERATE_ENTRIES);\n  },\n\n  every: function every(predicate, context) {\n    assertNotInfinite(this.size);\n    var returnValue = true;\n    this.__iterate(function (v, k, c) {\n      if (!predicate.call(context, v, k, c)) {\n        returnValue = false;\n        return false;\n      }\n    });\n    return returnValue;\n  },\n\n  filter: function filter(predicate, context) {\n    return reify(this, filterFactory(this, predicate, context, true));\n  },\n\n  find: function find(predicate, context, notSetValue) {\n    var entry = this.findEntry(predicate, context);\n    return entry ? entry[1] : notSetValue;\n  },\n\n  forEach: function forEach(sideEffect, context) {\n    assertNotInfinite(this.size);\n    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n  },\n\n  join: function join(separator) {\n    assertNotInfinite(this.size);\n    separator = separator !== undefined ? '' + separator : ',';\n    var joined = '';\n    var isFirst = true;\n    this.__iterate(function (v) {\n      isFirst ? (isFirst = false) : (joined += separator);\n      joined += v !== null && v !== undefined ? v.toString() : '';\n    });\n    return joined;\n  },\n\n  keys: function keys() {\n    return this.__iterator(ITERATE_KEYS);\n  },\n\n  map: function map(mapper, context) {\n    return reify(this, mapFactory(this, mapper, context));\n  },\n\n  reduce: function reduce$1(reducer, initialReduction, context) {\n    return reduce(\n      this,\n      reducer,\n      initialReduction,\n      context,\n      arguments.length < 2,\n      false\n    );\n  },\n\n  reduceRight: function reduceRight(reducer, initialReduction, context) {\n    return reduce(\n      this,\n      reducer,\n      initialReduction,\n      context,\n      arguments.length < 2,\n      true\n    );\n  },\n\n  reverse: function reverse() {\n    return reify(this, reverseFactory(this, true));\n  },\n\n  slice: function slice(begin, end) {\n    return reify(this, sliceFactory(this, begin, end, true));\n  },\n\n  some: function some(predicate, context) {\n    return !this.every(not(predicate), context);\n  },\n\n  sort: function sort(comparator) {\n    return reify(this, sortFactory(this, comparator));\n  },\n\n  values: function values() {\n    return this.__iterator(ITERATE_VALUES);\n  },\n\n  // ### More sequential methods\n\n  butLast: function butLast() {\n    return this.slice(0, -1);\n  },\n\n  isEmpty: function isEmpty() {\n    return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });\n  },\n\n  count: function count(predicate, context) {\n    return ensureSize(\n      predicate ? this.toSeq().filter(predicate, context) : this\n    );\n  },\n\n  countBy: function countBy(grouper, context) {\n    return countByFactory(this, grouper, context);\n  },\n\n  equals: function equals(other) {\n    return deepEqual(this, other);\n  },\n\n  entrySeq: function entrySeq() {\n    var collection = this;\n    if (collection._cache) {\n      // We cache as an entries array, so we can just return the cache!\n      return new ArraySeq(collection._cache);\n    }\n    var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();\n    entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };\n    return entriesSequence;\n  },\n\n  filterNot: function filterNot(predicate, context) {\n    return this.filter(not(predicate), context);\n  },\n\n  findEntry: function findEntry(predicate, context, notSetValue) {\n    var found = notSetValue;\n    this.__iterate(function (v, k, c) {\n      if (predicate.call(context, v, k, c)) {\n        found = [k, v];\n        return false;\n      }\n    });\n    return found;\n  },\n\n  findKey: function findKey(predicate, context) {\n    var entry = this.findEntry(predicate, context);\n    return entry && entry[0];\n  },\n\n  findLast: function findLast(predicate, context, notSetValue) {\n    return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n  },\n\n  findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n    return this.toKeyedSeq()\n      .reverse()\n      .findEntry(predicate, context, notSetValue);\n  },\n\n  findLastKey: function findLastKey(predicate, context) {\n    return this.toKeyedSeq().reverse().findKey(predicate, context);\n  },\n\n  first: function first(notSetValue) {\n    return this.find(returnTrue, null, notSetValue);\n  },\n\n  flatMap: function flatMap(mapper, context) {\n    return reify(this, flatMapFactory(this, mapper, context));\n  },\n\n  flatten: function flatten(depth) {\n    return reify(this, flattenFactory(this, depth, true));\n  },\n\n  fromEntrySeq: function fromEntrySeq() {\n    return new FromEntriesSequence(this);\n  },\n\n  get: function get(searchKey, notSetValue) {\n    return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);\n  },\n\n  getIn: getIn,\n\n  groupBy: function groupBy(grouper, context) {\n    return groupByFactory(this, grouper, context);\n  },\n\n  has: function has(searchKey) {\n    return this.get(searchKey, NOT_SET) !== NOT_SET;\n  },\n\n  hasIn: hasIn,\n\n  isSubset: function isSubset(iter) {\n    iter = typeof iter.includes === 'function' ? iter : Collection(iter);\n    return this.every(function (value) { return iter.includes(value); });\n  },\n\n  isSuperset: function isSuperset(iter) {\n    iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);\n    return iter.isSubset(this);\n  },\n\n  keyOf: function keyOf(searchValue) {\n    return this.findKey(function (value) { return is(value, searchValue); });\n  },\n\n  keySeq: function keySeq() {\n    return this.toSeq().map(keyMapper).toIndexedSeq();\n  },\n\n  last: function last(notSetValue) {\n    return this.toSeq().reverse().first(notSetValue);\n  },\n\n  lastKeyOf: function lastKeyOf(searchValue) {\n    return this.toKeyedSeq().reverse().keyOf(searchValue);\n  },\n\n  max: function max(comparator) {\n    return maxFactory(this, comparator);\n  },\n\n  maxBy: function maxBy(mapper, comparator) {\n    return maxFactory(this, comparator, mapper);\n  },\n\n  min: function min(comparator) {\n    return maxFactory(\n      this,\n      comparator ? neg(comparator) : defaultNegComparator\n    );\n  },\n\n  minBy: function minBy(mapper, comparator) {\n    return maxFactory(\n      this,\n      comparator ? neg(comparator) : defaultNegComparator,\n      mapper\n    );\n  },\n\n  rest: function rest() {\n    return this.slice(1);\n  },\n\n  skip: function skip(amount) {\n    return amount === 0 ? this : this.slice(Math.max(0, amount));\n  },\n\n  skipLast: function skipLast(amount) {\n    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n  },\n\n  skipWhile: function skipWhile(predicate, context) {\n    return reify(this, skipWhileFactory(this, predicate, context, true));\n  },\n\n  skipUntil: function skipUntil(predicate, context) {\n    return this.skipWhile(not(predicate), context);\n  },\n\n  sortBy: function sortBy(mapper, comparator) {\n    return reify(this, sortFactory(this, comparator, mapper));\n  },\n\n  take: function take(amount) {\n    return this.slice(0, Math.max(0, amount));\n  },\n\n  takeLast: function takeLast(amount) {\n    return this.slice(-Math.max(0, amount));\n  },\n\n  takeWhile: function takeWhile(predicate, context) {\n    return reify(this, takeWhileFactory(this, predicate, context));\n  },\n\n  takeUntil: function takeUntil(predicate, context) {\n    return this.takeWhile(not(predicate), context);\n  },\n\n  update: function update(fn) {\n    return fn(this);\n  },\n\n  valueSeq: function valueSeq() {\n    return this.toIndexedSeq();\n  },\n\n  // ### Hashable Object\n\n  hashCode: function hashCode() {\n    return this.__hash || (this.__hash = hashCollection(this));\n  },\n\n  // ### Internal\n\n  // abstract __iterate(fn, reverse)\n\n  // abstract __iterator(type, reverse)\n});\n\nvar CollectionPrototype = Collection.prototype;\nCollectionPrototype[IS_COLLECTION_SYMBOL] = true;\nCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\nCollectionPrototype.toJSON = CollectionPrototype.toArray;\nCollectionPrototype.__toStringMapper = quoteString;\nCollectionPrototype.inspect = CollectionPrototype.toSource = function () {\n  return this.toString();\n};\nCollectionPrototype.chain = CollectionPrototype.flatMap;\nCollectionPrototype.contains = CollectionPrototype.includes;\n\nmixin(KeyedCollection, {\n  // ### More sequential methods\n\n  flip: function flip() {\n    return reify(this, flipFactory(this));\n  },\n\n  mapEntries: function mapEntries(mapper, context) {\n    var this$1$1 = this;\n\n    var iterations = 0;\n    return reify(\n      this,\n      this.toSeq()\n        .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1$1); })\n        .fromEntrySeq()\n    );\n  },\n\n  mapKeys: function mapKeys(mapper, context) {\n    var this$1$1 = this;\n\n    return reify(\n      this,\n      this.toSeq()\n        .flip()\n        .map(function (k, v) { return mapper.call(context, k, v, this$1$1); })\n        .flip()\n    );\n  },\n});\n\nvar KeyedCollectionPrototype = KeyedCollection.prototype;\nKeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;\nKeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\nKeyedCollectionPrototype.toJSON = toObject;\nKeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };\n\nmixin(IndexedCollection, {\n  // ### Conversion to other types\n\n  toKeyedSeq: function toKeyedSeq() {\n    return new ToKeyedSequence(this, false);\n  },\n\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  filter: function filter(predicate, context) {\n    return reify(this, filterFactory(this, predicate, context, false));\n  },\n\n  findIndex: function findIndex(predicate, context) {\n    var entry = this.findEntry(predicate, context);\n    return entry ? entry[0] : -1;\n  },\n\n  indexOf: function indexOf(searchValue) {\n    var key = this.keyOf(searchValue);\n    return key === undefined ? -1 : key;\n  },\n\n  lastIndexOf: function lastIndexOf(searchValue) {\n    var key = this.lastKeyOf(searchValue);\n    return key === undefined ? -1 : key;\n  },\n\n  reverse: function reverse() {\n    return reify(this, reverseFactory(this, false));\n  },\n\n  slice: function slice(begin, end) {\n    return reify(this, sliceFactory(this, begin, end, false));\n  },\n\n  splice: function splice(index, removeNum /*, ...values*/) {\n    var numArgs = arguments.length;\n    removeNum = Math.max(removeNum || 0, 0);\n    if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n      return this;\n    }\n    // If index is negative, it should resolve relative to the size of the\n    // collection. However size may be expensive to compute if not cached, so\n    // only call count() if the number is in fact negative.\n    index = resolveBegin(index, index < 0 ? this.count() : this.size);\n    var spliced = this.slice(0, index);\n    return reify(\n      this,\n      numArgs === 1\n        ? spliced\n        : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n    );\n  },\n\n  // ### More collection methods\n\n  findLastIndex: function findLastIndex(predicate, context) {\n    var entry = this.findLastEntry(predicate, context);\n    return entry ? entry[0] : -1;\n  },\n\n  first: function first(notSetValue) {\n    return this.get(0, notSetValue);\n  },\n\n  flatten: function flatten(depth) {\n    return reify(this, flattenFactory(this, depth, false));\n  },\n\n  get: function get(index, notSetValue) {\n    index = wrapIndex(this, index);\n    return index < 0 ||\n      this.size === Infinity ||\n      (this.size !== undefined && index > this.size)\n      ? notSetValue\n      : this.find(function (_, key) { return key === index; }, undefined, notSetValue);\n  },\n\n  has: function has(index) {\n    index = wrapIndex(this, index);\n    return (\n      index >= 0 &&\n      (this.size !== undefined\n        ? this.size === Infinity || index < this.size\n        : this.indexOf(index) !== -1)\n    );\n  },\n\n  interpose: function interpose(separator) {\n    return reify(this, interposeFactory(this, separator));\n  },\n\n  interleave: function interleave(/*...collections*/) {\n    var collections = [this].concat(arrCopy(arguments));\n    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n    var interleaved = zipped.flatten(true);\n    if (zipped.size) {\n      interleaved.size = zipped.size * collections.length;\n    }\n    return reify(this, interleaved);\n  },\n\n  keySeq: function keySeq() {\n    return Range(0, this.size);\n  },\n\n  last: function last(notSetValue) {\n    return this.get(-1, notSetValue);\n  },\n\n  skipWhile: function skipWhile(predicate, context) {\n    return reify(this, skipWhileFactory(this, predicate, context, false));\n  },\n\n  zip: function zip(/*, ...collections */) {\n    var collections = [this].concat(arrCopy(arguments));\n    return reify(this, zipWithFactory(this, defaultZipper, collections));\n  },\n\n  zipAll: function zipAll(/*, ...collections */) {\n    var collections = [this].concat(arrCopy(arguments));\n    return reify(this, zipWithFactory(this, defaultZipper, collections, true));\n  },\n\n  zipWith: function zipWith(zipper /*, ...collections */) {\n    var collections = arrCopy(arguments);\n    collections[0] = this;\n    return reify(this, zipWithFactory(this, zipper, collections));\n  },\n});\n\nvar IndexedCollectionPrototype = IndexedCollection.prototype;\nIndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;\nIndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;\n\nmixin(SetCollection, {\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  get: function get(value, notSetValue) {\n    return this.has(value) ? value : notSetValue;\n  },\n\n  includes: function includes(value) {\n    return this.has(value);\n  },\n\n  // ### More sequential methods\n\n  keySeq: function keySeq() {\n    return this.valueSeq();\n  },\n});\n\nvar SetCollectionPrototype = SetCollection.prototype;\nSetCollectionPrototype.has = CollectionPrototype.includes;\nSetCollectionPrototype.contains = SetCollectionPrototype.includes;\nSetCollectionPrototype.keys = SetCollectionPrototype.values;\n\n// Mixin subclasses\n\nmixin(KeyedSeq, KeyedCollectionPrototype);\nmixin(IndexedSeq, IndexedCollectionPrototype);\nmixin(SetSeq, SetCollectionPrototype);\n\n// #pragma Helper functions\n\nfunction reduce(collection, reducer, reduction, context, useFirst, reverse) {\n  assertNotInfinite(collection.size);\n  collection.__iterate(function (v, k, c) {\n    if (useFirst) {\n      useFirst = false;\n      reduction = v;\n    } else {\n      reduction = reducer.call(context, reduction, v, k, c);\n    }\n  }, reverse);\n  return reduction;\n}\n\nfunction keyMapper(v, k) {\n  return k;\n}\n\nfunction entryMapper(v, k) {\n  return [k, v];\n}\n\nfunction not(predicate) {\n  return function () {\n    return !predicate.apply(this, arguments);\n  };\n}\n\nfunction neg(predicate) {\n  return function () {\n    return -predicate.apply(this, arguments);\n  };\n}\n\nfunction defaultZipper() {\n  return arrCopy(arguments);\n}\n\nfunction defaultNegComparator(a, b) {\n  return a < b ? 1 : a > b ? -1 : 0;\n}\n\nfunction hashCollection(collection) {\n  if (collection.size === Infinity) {\n    return 0;\n  }\n  var ordered = isOrdered(collection);\n  var keyed = isKeyed(collection);\n  var h = ordered ? 1 : 0;\n  var size = collection.__iterate(\n    keyed\n      ? ordered\n        ? function (v, k) {\n            h = (31 * h + hashMerge(hash(v), hash(k))) | 0;\n          }\n        : function (v, k) {\n            h = (h + hashMerge(hash(v), hash(k))) | 0;\n          }\n      : ordered\n      ? function (v) {\n          h = (31 * h + hash(v)) | 0;\n        }\n      : function (v) {\n          h = (h + hash(v)) | 0;\n        }\n  );\n  return murmurHashOfSize(size, h);\n}\n\nfunction murmurHashOfSize(size, h) {\n  h = imul(h, 0xcc9e2d51);\n  h = imul((h << 15) | (h >>> -15), 0x1b873593);\n  h = imul((h << 13) | (h >>> -13), 5);\n  h = ((h + 0xe6546b64) | 0) ^ size;\n  h = imul(h ^ (h >>> 16), 0x85ebca6b);\n  h = imul(h ^ (h >>> 13), 0xc2b2ae35);\n  h = smi(h ^ (h >>> 16));\n  return h;\n}\n\nfunction hashMerge(a, b) {\n  return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0; // int\n}\n\nvar OrderedSet = /*@__PURE__*/(function (Set) {\n  function OrderedSet(value) {\n    return value === null || value === undefined\n      ? emptyOrderedSet()\n      : isOrderedSet(value)\n      ? value\n      : emptyOrderedSet().withMutations(function (set) {\n          var iter = SetCollection(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function (v) { return set.add(v); });\n        });\n  }\n\n  if ( Set ) OrderedSet.__proto__ = Set;\n  OrderedSet.prototype = Object.create( Set && Set.prototype );\n  OrderedSet.prototype.constructor = OrderedSet;\n\n  OrderedSet.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  OrderedSet.fromKeys = function fromKeys (value) {\n    return this(KeyedCollection(value).keySeq());\n  };\n\n  OrderedSet.prototype.toString = function toString () {\n    return this.__toString('OrderedSet {', '}');\n  };\n\n  return OrderedSet;\n}(Set));\n\nOrderedSet.isOrderedSet = isOrderedSet;\n\nvar OrderedSetPrototype = OrderedSet.prototype;\nOrderedSetPrototype[IS_ORDERED_SYMBOL] = true;\nOrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\nOrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\nOrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;\n\nOrderedSetPrototype.__empty = emptyOrderedSet;\nOrderedSetPrototype.__make = makeOrderedSet;\n\nfunction makeOrderedSet(map, ownerID) {\n  var set = Object.create(OrderedSetPrototype);\n  set.size = map ? map.size : 0;\n  set._map = map;\n  set.__ownerID = ownerID;\n  return set;\n}\n\nvar EMPTY_ORDERED_SET;\nfunction emptyOrderedSet() {\n  return (\n    EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()))\n  );\n}\n\nfunction throwOnInvalidDefaultValues(defaultValues) {\n  if (isRecord(defaultValues)) {\n    throw new Error(\n      'Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead.'\n    );\n  }\n\n  if (isImmutable(defaultValues)) {\n    throw new Error(\n      'Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead.'\n    );\n  }\n\n  if (defaultValues === null || typeof defaultValues !== 'object') {\n    throw new Error(\n      'Can not call `Record` with a non-object as default values. Use a plain javascript object instead.'\n    );\n  }\n}\n\nvar Record = function Record(defaultValues, name) {\n  var hasInitialized;\n\n  throwOnInvalidDefaultValues(defaultValues);\n\n  var RecordType = function Record(values) {\n    var this$1$1 = this;\n\n    if (values instanceof RecordType) {\n      return values;\n    }\n    if (!(this instanceof RecordType)) {\n      return new RecordType(values);\n    }\n    if (!hasInitialized) {\n      hasInitialized = true;\n      var keys = Object.keys(defaultValues);\n      var indices = (RecordTypePrototype._indices = {});\n      // Deprecated: left to attempt not to break any external code which\n      // relies on a ._name property existing on record instances.\n      // Use Record.getDescriptiveName() instead\n      RecordTypePrototype._name = name;\n      RecordTypePrototype._keys = keys;\n      RecordTypePrototype._defaultValues = defaultValues;\n      for (var i = 0; i < keys.length; i++) {\n        var propName = keys[i];\n        indices[propName] = i;\n        if (RecordTypePrototype[propName]) {\n          /* eslint-disable no-console */\n          typeof console === 'object' &&\n            console.warn &&\n            console.warn(\n              'Cannot define ' +\n                recordName(this) +\n                ' with property \"' +\n                propName +\n                '\" since that property name is part of the Record API.'\n            );\n          /* eslint-enable no-console */\n        } else {\n          setProp(RecordTypePrototype, propName);\n        }\n      }\n    }\n    this.__ownerID = undefined;\n    this._values = List().withMutations(function (l) {\n      l.setSize(this$1$1._keys.length);\n      KeyedCollection(values).forEach(function (v, k) {\n        l.set(this$1$1._indices[k], v === this$1$1._defaultValues[k] ? undefined : v);\n      });\n    });\n    return this;\n  };\n\n  var RecordTypePrototype = (RecordType.prototype =\n    Object.create(RecordPrototype));\n  RecordTypePrototype.constructor = RecordType;\n\n  if (name) {\n    RecordType.displayName = name;\n  }\n\n  return RecordType;\n};\n\nRecord.prototype.toString = function toString () {\n  var str = recordName(this) + ' { ';\n  var keys = this._keys;\n  var k;\n  for (var i = 0, l = keys.length; i !== l; i++) {\n    k = keys[i];\n    str += (i ? ', ' : '') + k + ': ' + quoteString(this.get(k));\n  }\n  return str + ' }';\n};\n\nRecord.prototype.equals = function equals (other) {\n  return (\n    this === other || (other && recordSeq(this).equals(recordSeq(other)))\n  );\n};\n\nRecord.prototype.hashCode = function hashCode () {\n  return recordSeq(this).hashCode();\n};\n\n// @pragma Access\n\nRecord.prototype.has = function has (k) {\n  return this._indices.hasOwnProperty(k);\n};\n\nRecord.prototype.get = function get (k, notSetValue) {\n  if (!this.has(k)) {\n    return notSetValue;\n  }\n  var index = this._indices[k];\n  var value = this._values.get(index);\n  return value === undefined ? this._defaultValues[k] : value;\n};\n\n// @pragma Modification\n\nRecord.prototype.set = function set (k, v) {\n  if (this.has(k)) {\n    var newValues = this._values.set(\n      this._indices[k],\n      v === this._defaultValues[k] ? undefined : v\n    );\n    if (newValues !== this._values && !this.__ownerID) {\n      return makeRecord(this, newValues);\n    }\n  }\n  return this;\n};\n\nRecord.prototype.remove = function remove (k) {\n  return this.set(k);\n};\n\nRecord.prototype.clear = function clear () {\n  var newValues = this._values.clear().setSize(this._keys.length);\n\n  return this.__ownerID ? this : makeRecord(this, newValues);\n};\n\nRecord.prototype.wasAltered = function wasAltered () {\n  return this._values.wasAltered();\n};\n\nRecord.prototype.toSeq = function toSeq () {\n  return recordSeq(this);\n};\n\nRecord.prototype.toJS = function toJS$1 () {\n  return toJS(this);\n};\n\nRecord.prototype.entries = function entries () {\n  return this.__iterator(ITERATE_ENTRIES);\n};\n\nRecord.prototype.__iterator = function __iterator (type, reverse) {\n  return recordSeq(this).__iterator(type, reverse);\n};\n\nRecord.prototype.__iterate = function __iterate (fn, reverse) {\n  return recordSeq(this).__iterate(fn, reverse);\n};\n\nRecord.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n  if (ownerID === this.__ownerID) {\n    return this;\n  }\n  var newValues = this._values.__ensureOwner(ownerID);\n  if (!ownerID) {\n    this.__ownerID = ownerID;\n    this._values = newValues;\n    return this;\n  }\n  return makeRecord(this, newValues, ownerID);\n};\n\nRecord.isRecord = isRecord;\nRecord.getDescriptiveName = recordName;\nvar RecordPrototype = Record.prototype;\nRecordPrototype[IS_RECORD_SYMBOL] = true;\nRecordPrototype[DELETE] = RecordPrototype.remove;\nRecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;\nRecordPrototype.getIn = getIn;\nRecordPrototype.hasIn = CollectionPrototype.hasIn;\nRecordPrototype.merge = merge$1;\nRecordPrototype.mergeWith = mergeWith$1;\nRecordPrototype.mergeIn = mergeIn;\nRecordPrototype.mergeDeep = mergeDeep;\nRecordPrototype.mergeDeepWith = mergeDeepWith;\nRecordPrototype.mergeDeepIn = mergeDeepIn;\nRecordPrototype.setIn = setIn;\nRecordPrototype.update = update;\nRecordPrototype.updateIn = updateIn;\nRecordPrototype.withMutations = withMutations;\nRecordPrototype.asMutable = asMutable;\nRecordPrototype.asImmutable = asImmutable;\nRecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;\nRecordPrototype.toJSON = RecordPrototype.toObject =\n  CollectionPrototype.toObject;\nRecordPrototype.inspect = RecordPrototype.toSource = function () {\n  return this.toString();\n};\n\nfunction makeRecord(likeRecord, values, ownerID) {\n  var record = Object.create(Object.getPrototypeOf(likeRecord));\n  record._values = values;\n  record.__ownerID = ownerID;\n  return record;\n}\n\nfunction recordName(record) {\n  return record.constructor.displayName || record.constructor.name || 'Record';\n}\n\nfunction recordSeq(record) {\n  return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));\n}\n\nfunction setProp(prototype, name) {\n  try {\n    Object.defineProperty(prototype, name, {\n      get: function () {\n        return this.get(name);\n      },\n      set: function (value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      },\n    });\n  } catch (error) {\n    // Object.defineProperty failed. Probably IE8.\n  }\n}\n\n/**\n * Returns a lazy Seq of `value` repeated `times` times. When `times` is\n * undefined, returns an infinite sequence of `value`.\n */\nvar Repeat = /*@__PURE__*/(function (IndexedSeq) {\n  function Repeat(value, times) {\n    if (!(this instanceof Repeat)) {\n      return new Repeat(value, times);\n    }\n    this._value = value;\n    this.size = times === undefined ? Infinity : Math.max(0, times);\n    if (this.size === 0) {\n      if (EMPTY_REPEAT) {\n        return EMPTY_REPEAT;\n      }\n      EMPTY_REPEAT = this;\n    }\n  }\n\n  if ( IndexedSeq ) Repeat.__proto__ = IndexedSeq;\n  Repeat.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  Repeat.prototype.constructor = Repeat;\n\n  Repeat.prototype.toString = function toString () {\n    if (this.size === 0) {\n      return 'Repeat []';\n    }\n    return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n  };\n\n  Repeat.prototype.get = function get (index, notSetValue) {\n    return this.has(index) ? this._value : notSetValue;\n  };\n\n  Repeat.prototype.includes = function includes (searchValue) {\n    return is(this._value, searchValue);\n  };\n\n  Repeat.prototype.slice = function slice (begin, end) {\n    var size = this.size;\n    return wholeSlice(begin, end, size)\n      ? this\n      : new Repeat(\n          this._value,\n          resolveEnd(end, size) - resolveBegin(begin, size)\n        );\n  };\n\n  Repeat.prototype.reverse = function reverse () {\n    return this;\n  };\n\n  Repeat.prototype.indexOf = function indexOf (searchValue) {\n    if (is(this._value, searchValue)) {\n      return 0;\n    }\n    return -1;\n  };\n\n  Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n    if (is(this._value, searchValue)) {\n      return this.size;\n    }\n    return -1;\n  };\n\n  Repeat.prototype.__iterate = function __iterate (fn, reverse) {\n    var size = this.size;\n    var i = 0;\n    while (i !== size) {\n      if (fn(this._value, reverse ? size - ++i : i++, this) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  Repeat.prototype.__iterator = function __iterator (type, reverse) {\n    var this$1$1 = this;\n\n    var size = this.size;\n    var i = 0;\n    return new Iterator(function () { return i === size\n        ? iteratorDone()\n        : iteratorValue(type, reverse ? size - ++i : i++, this$1$1._value); }\n    );\n  };\n\n  Repeat.prototype.equals = function equals (other) {\n    return other instanceof Repeat\n      ? is(this._value, other._value)\n      : deepEqual(other);\n  };\n\n  return Repeat;\n}(IndexedSeq));\n\nvar EMPTY_REPEAT;\n\nfunction fromJS(value, converter) {\n  return fromJSWith(\n    [],\n    converter || defaultConverter,\n    value,\n    '',\n    converter && converter.length > 2 ? [] : undefined,\n    { '': value }\n  );\n}\n\nfunction fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n  if (\n    typeof value !== 'string' &&\n    !isImmutable(value) &&\n    (isArrayLike(value) || hasIterator(value) || isPlainObject(value))\n  ) {\n    if (~stack.indexOf(value)) {\n      throw new TypeError('Cannot convert circular structure to Immutable');\n    }\n    stack.push(value);\n    keyPath && key !== '' && keyPath.push(key);\n    var converted = converter.call(\n      parentValue,\n      key,\n      Seq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }\n      ),\n      keyPath && keyPath.slice()\n    );\n    stack.pop();\n    keyPath && keyPath.pop();\n    return converted;\n  }\n  return value;\n}\n\nfunction defaultConverter(k, v) {\n  // Effectively the opposite of \"Collection.toSeq()\"\n  return isIndexed(v) ? v.toList() : isKeyed(v) ? v.toMap() : v.toSet();\n}\n\nvar version = \"4.0.0\";\n\nvar Immutable = {\n  version: version,\n\n  Collection: Collection,\n  // Note: Iterable is deprecated\n  Iterable: Collection,\n\n  Seq: Seq,\n  Map: Map,\n  OrderedMap: OrderedMap,\n  List: List,\n  Stack: Stack,\n  Set: Set,\n  OrderedSet: OrderedSet,\n\n  Record: Record,\n  Range: Range,\n  Repeat: Repeat,\n\n  is: is,\n  fromJS: fromJS,\n  hash: hash,\n\n  isImmutable: isImmutable,\n  isCollection: isCollection,\n  isKeyed: isKeyed,\n  isIndexed: isIndexed,\n  isAssociative: isAssociative,\n  isOrdered: isOrdered,\n  isValueObject: isValueObject,\n  isPlainObject: isPlainObject,\n  isSeq: isSeq,\n  isList: isList,\n  isMap: isMap,\n  isOrderedMap: isOrderedMap,\n  isStack: isStack,\n  isSet: isSet,\n  isOrderedSet: isOrderedSet,\n  isRecord: isRecord,\n\n  get: get,\n  getIn: getIn$1,\n  has: has,\n  hasIn: hasIn$1,\n  merge: merge,\n  mergeDeep: mergeDeep$1,\n  mergeWith: mergeWith,\n  mergeDeepWith: mergeDeepWith$1,\n  remove: remove,\n  removeIn: removeIn,\n  set: set,\n  setIn: setIn$1,\n  update: update$1,\n  updateIn: updateIn$1,\n};\n\n// Note: Iterable is deprecated\nvar Iterable = Collection;\n\nexport default Immutable;\nexport { Collection, Iterable, List, Map, OrderedMap, OrderedSet, Range, Record, Repeat, Seq, Set, Stack, fromJS, get, getIn$1 as getIn, has, hasIn$1 as hasIn, hash, is, isAssociative, isCollection, isImmutable, isIndexed, isKeyed, isList, isMap, isOrdered, isOrderedMap, isOrderedSet, isPlainObject, isRecord, isSeq, isSet, isStack, isValueObject, merge, mergeDeep$1 as mergeDeep, mergeDeepWith$1 as mergeDeepWith, mergeWith, remove, removeIn, set, setIn$1 as setIn, update$1 as update, updateIn$1 as updateIn, version };\n","module.exports = __WEBPACK_EXTERNAL_MODULE_react__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/sfd.js\");\n",""],"names":["keyUtil","require","Leaf","Decorator","ContentBlock","EditorState","React","List","Block","props","blockKey","offsetKey","renderChildren","block","tree","decorator","text","getText","map","blockRange","key1","decoratorKey","get","leaves","start","end","size","Leaves","leafRange","key2","encodin","leafProps","slice","inlineStyle","getStyleAt","toArray","decoratorOffsetKey","DecoratorComponent","getComponentForKey","decoratorProps","getPropsForKey","decoratorProps1","first","Component","module","exports","Tree","ContentState","Content","editor","editorState","content","getContent","trees","getTreeMap","getDecorator","Blocks","key","getBlockForKey","push","keyMap","eventHandler","UpdateEditor","sync","_latestEditorState","_blockSelectEvent","Editor","node","editorContainer","firstChild","onKeyDown","buildHandler","onBeforeInput","onInput","onSelect","readOnly","style","outline","userSelect","WebkitUserSelect","whiteSpace","wordWrap","renderPlaceholder","refContainer","placeHolder","withHolder","toString","trim","withContent","getBlockMap","some","length","onChange","event","e","handler","TextNode","styleMap","reduce","styles","_","Object","assign","newLine","children","onKeyUp","onMouseUp","modifier","_this","console","log","data","selection","getSelection","getInlineStyle","chars","collapsed","newEditorState","replaceChars","preventDefault","_pendingEditorState","editorStateOptions","getSelectionAfter","set","asserts","findOffsetKey","DOMModifier","undefined","rawSelection","anchorNode","anchorOffset","isCollapsed","domText","textContent","anchorKeys","getTree","getIn","leafKey","anchorBlock","modelText","inputType","nativeEvent","keys","keyCode","RETURN","SPACE","command","handle","getCastSelection","castSelection","getContentEditable","acceptSelection","container","isHTMLElement","ctrlKey","BACKSPACE","B","TAB","ESC","LEFT","UP","RIGHT","DOWN","D","H","I","J","K","M","O","T","U","W","Y","Z","SelectionState","focusKeys","focusOffset","anchorTree","anchorLeaf","focusTree","focusLeaf","anchorLeafStart","anchorBlockOffset","focusLeafStart","focusBlockOffset","merge","anchorKey","focusKey","getOffsetKey","root","paren","decodin","parentNode","focusNode","rangeCount","anchorIsTextNode","nodeType","Node","TEXT_NODE","focusIsTextNode","isElement","castNode","getAttribute","ownerDocument","ELEMENT_NODE","BOLD","fontWeight","ITALIC","fontStyle","CODE","fontFamily","UNDERLINE","textDecoration","LINETHROUGH","BOLD_ITALIC","findRange","Repeat","decorators","_decorators","list","Array","fill","forEach","options","index","strategy","counts","checker","canFill","DELIMITER","parseInt","split","component","i","Record","Map","OrderedSet","EMPTYSET","defaultConfig","entity","CharMetaRecord","CharMeta","config","EMPTY","copy","pool","charMeta","type","charMetas","ContentBlockRecord","offset","getCharMetas","getStyle","OrderedMap","blockMap","selectionBefore","selectionAfter","ContentStateRecord","delimiter","strings","blocks","string","random","createWithArray","isEmpty","createEmpty","getKey","treeMap","EditorStateRecord","immu","_immu","getInlineStyleCollapsed","getAnchorKey","getAnchorOffset","withConfig","newTreeMap","createWithText","create","record","withMutations","renewTreeMap","toOrderedMap","oldContent","oldBlockMap","newBlockMap","toSeq","filter","SelectionStateRecord","getFocusKey","getFocusOffset","defaultLeaf","LeafRange","defaultBlock","BlockRange","findBlock","decorations","ranges","equal","findLeaf","inlineStyles","toList","a","b","of","getDecorations","callback","cursor","total","currentValue","currentIndex","last","count","DOMmodifier","document","defaultView","insertToList","startKey","startOffset","newBlock","newOffset","partial","_list","reverse","unshift","before","after","concat","sfd","predicate","format","args","error","replace","Error","MULTIPLIER","Math","pow","hasOwnProperty","isNaN","floor","key3","join"],"sourceRoot":""}